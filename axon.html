<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>cybertensor.axon API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cybertensor.axon</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="cybertensor.axon.create_error_response"><code class="name flex">
<span>def <span class="ident">create_error_response</span></span>(<span>synapse: <a title="cybertensor.synapse.Synapse" href="synapse.html#cybertensor.synapse.Synapse">Synapse</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cybertensor.axon.log_and_handle_error"><code class="name flex">
<span>def <span class="ident">log_and_handle_error</span></span>(<span>synapse: <a title="cybertensor.synapse.Synapse" href="synapse.html#cybertensor.synapse.Synapse">Synapse</a>, exception: Exception, status_code: int, start_time: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cybertensor.axon.AxonMiddleware"><code class="flex name class">
<span>class <span class="ident">AxonMiddleware</span></span>
<span>(</span><span>app: <a title="cybertensor.axon.AxonMiddleware" href="#cybertensor.axon.AxonMiddleware">AxonMiddleware</a>, axon: <a title="cybertensor.axon" href="#cybertensor.axon">cybertensor.axon</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="cybertensor.axon.AxonMiddleware" href="#cybertensor.axon.AxonMiddleware">AxonMiddleware</a></code> class is a key component in the Axon server, responsible for processing all incoming requests.
It handles the essential tasks of verifying requests, executing blacklist checks,
running priority functions, and managing the logging of messages and errors. Additionally, the class
is responsible for updating the headers of the response and executing the requested functions.
This middleware acts as an intermediary layer in request handling, ensuring that each request is
processed according to the defined rules and protocols of the cybertensor network. It plays a pivotal
role in maintaining the integrity and security of the network communication.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>app</code></strong> :&ensp;<code>FastAPI</code></dt>
<dd>An instance of the FastAPI application to which this middleware is attached.</dd>
<dt><strong><code>axon</code></strong> :&ensp;<code><a title="cybertensor.axon" href="#cybertensor.axon">cybertensor.axon</a></code></dt>
<dd>The Axon instance that will process the requests.</dd>
</dl>
<p>The middleware operates by intercepting incoming requests, performing necessary preprocessing
(like verification and priority assessment), executing the request through the Axon's endpoints, and
then handling any postprocessing steps such as response header updating and logging.</p>
<p>Initialize the AxonMiddleware class.</p>
<p>Args:
app (object): An instance of the application where the middleware processor is used.
axon (object): The axon instance used to process the requests.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AxonMiddleware(BaseHTTPMiddleware):
    &#34;&#34;&#34;
    The `AxonMiddleware` class is a key component in the Axon server, responsible for processing all incoming requests.
    It handles the essential tasks of verifying requests, executing blacklist checks,
    running priority functions, and managing the logging of messages and errors. Additionally, the class
    is responsible for updating the headers of the response and executing the requested functions.
    This middleware acts as an intermediary layer in request handling, ensuring that each request is
    processed according to the defined rules and protocols of the cybertensor network. It plays a pivotal
    role in maintaining the integrity and security of the network communication.
    Args:
        app (FastAPI): An instance of the FastAPI application to which this middleware is attached.
        axon (cybertensor.axon): The Axon instance that will process the requests.
    The middleware operates by intercepting incoming requests, performing necessary preprocessing
    (like verification and priority assessment), executing the request through the Axon&#39;s endpoints, and
    then handling any postprocessing steps such as response header updating and logging.
    &#34;&#34;&#34;

    def __init__(self, app: &#34;AxonMiddleware&#34;, axon: &#34;cybertensor.axon&#34;):
        &#34;&#34;&#34;
        Initialize the AxonMiddleware class.

        Args:
        app (object): An instance of the application where the middleware processor is used.
        axon (object): The axon instance used to process the requests.
        &#34;&#34;&#34;
        super().__init__(app)
        self.axon = axon

    async def dispatch(
        self, request: Request, call_next: RequestResponseEndpoint
    ) -&gt; Response:
        &#34;&#34;&#34;
        Asynchronously processes incoming HTTP requests and returns the corresponding responses. This
        method acts as the central processing unit of the AxonMiddleware, handling each step in the
        request lifecycle.
        Args:
            request (Request): The incoming HTTP request to be processed.
            call_next (RequestResponseEndpoint): A callable that processes the request and returns a response.
        Returns:
            Response: The HTTP response generated after processing the request.
        This method performs several key functions:
        1. Request Preprocessing: Sets up Synapse object from request headers and fills necessary information.
        2. Logging: Logs the start of request processing.
        3. Blacklist Checking: Verifies if the request is blacklisted.
        4. Request Verification: Ensures the authenticity and integrity of the request.
        5. Priority Assessment: Evaluates and assigns priority to the request.
        6. Request Execution: Calls the next function in the middleware chain to process the request.
        7. Response Postprocessing: Updates response headers and logs the end of the request processing.

        The method also handles exceptions and errors that might occur during each stage, ensuring that
        appropriate responses are returned to the client.
        &#34;&#34;&#34;
        # Records the start time of the request processing.
        start_time = time.time()

        try:
            # Set up the synapse from its headers.
            synapse: cybertensor.Synapse = await self.preprocess(request)

            # Logs the start of the request processing
            if synapse.dendrite is not None:
                cybertensor.logging.trace(
                    f&#34;axon     | &lt;-- | {request.headers.get(&#39;content-length&#39;, -1)} B | {synapse.name} | &#34;
                    f&#34;{synapse.dendrite.hotkey} | {synapse.dendrite.ip}:{synapse.dendrite.port} | 200 | Success &#34;
                )
            else:
                cybertensor.logging.trace(
                    f&#34;axon     | &lt;-- | {request.headers.get(&#39;content-length&#39;, -1)} B | {synapse.name} | &#34;
                    f&#34;None | None | 200 | Success &#34;
                )

            # Call the blacklist function
            await self.blacklist(synapse)

            # Call verify and return the verified request
            await self.verify(synapse)

            # Call the priority function
            await self.priority(synapse)

            # Call the run function
            response = await self.run(synapse, call_next, request)

            # Call the postprocess function
            response = await self.postprocess(synapse, response, start_time)

        # Catch the error case where axon is not configured to handle the request.
        except KeyError:
            # Extracts the request name from the URL path.
            request_name = request.url.path.split(&#34;/&#34;)[1]

            # Log key error.
            cybertensor.logging.error(
                f&#34;Key Error: Synapse name {request_name} not found.&#34;
            )

            # Create a synapse instance with status code 404 (not found) and status message.
            synapse: cybertensor.Synapse = cybertensor.Synapse()
            synapse.axon.status_code = &#34;404&#34;
            synapse.axon.status_message = f&#34;Synapse name {request_name} not found.&#34;

            # Create a JSON response with a status code of 404 (not found error),
            # synapse headers, and an empty content.
            response = JSONResponse(
                status_code=404, headers=synapse.to_headers(), content={}
            )

        # Handle errors related to preprocess.
        except InvalidRequestNameError as e:
            if &#34;synapse&#34; not in locals():
                synapse: cybertensor.Synapse = cybertensor.Synapse()  # type: ignore
            log_and_handle_error(synapse, e, 400, start_time)
            response = create_error_response(synapse)

        except SynapseParsingError as e:
            if &#34;synapse&#34; not in locals():
                synapse = cybertensor.Synapse()
            log_and_handle_error(synapse, e, 400, start_time)
            response = create_error_response(synapse)

        except UnknownSynapseError as e:
            if &#34;synapse&#34; not in locals():
                synapse = cybertensor.Synapse()
            log_and_handle_error(synapse, e, 404, start_time)
            response = create_error_response(synapse)

        # Handle errors related to verify.
        except NotVerifiedException as e:
            log_and_handle_error(synapse, e, 401, start_time)
            response = create_error_response(synapse)

        # Handle errors related to blacklist.
        except BlacklistedException as e:
            log_and_handle_error(synapse, e, 403, start_time)
            response = create_error_response(synapse)

        # Handle errors related to priority.
        except PriorityException as e:
            log_and_handle_error(synapse, e, 503, start_time)
            response = create_error_response(synapse)

        # Handle errors related to run.
        except RunException as e:
            log_and_handle_error(synapse, e, 500, start_time)
            response = create_error_response(synapse)

        # Handle errors related to postprocess.
        except PostProcessException as e:
            log_and_handle_error(synapse, e, 500, start_time)
            response = create_error_response(synapse)

        # Handle all other errors.
        except Exception as e:
            log_and_handle_error(synapse, InternalServerError(str(e)), 500, start_time)
            response = create_error_response(synapse)

        # Logs the end of request processing and returns the response
        finally:
            # Log the details of the processed synapse, including total size, name, hotkey, IP, port,
            # status code, and status message, using the debug level of the logger.
            if synapse.dendrite is not None and synapse.axon is not None:
                cybertensor.logging.trace(
                    f&#34;axon     | --&gt; | {response.headers.get(&#39;content-length&#39;, -1)} B | {synapse.name} | {synapse.dendrite.hotkey} | {synapse.dendrite.ip}:{synapse.dendrite.port}  | {synapse.axon.status_code} | {synapse.axon.status_message}&#34;
                )
            elif synapse.axon is not None:
                cybertensor.logging.trace(
                    f&#34;axon     | --&gt; | {response.headers.get(&#39;content-length&#39;, -1)} B | {synapse.name} | None | None | {synapse.axon.status_code} | {synapse.axon.status_message}&#34;
                )
            else:
                cybertensor.logging.trace(
                    f&#34;axon     | --&gt; | {response.headers.get(&#39;content-length&#39;, -1)} B | {synapse.name} | None | None | 200 | Success &#34;
                )

            # Return the response to the requester.
            return response

    async def preprocess(self, request: Request) -&gt; cybertensor.Synapse:
        &#34;&#34;&#34;
        Performs the initial processing of the incoming request. This method is responsible for
        extracting relevant information from the request and setting up the Synapse object, which
        represents the state and context of the request within the Axon server.
        Args:
            request (Request): The incoming request to be preprocessed.
        Returns:
            cybertensor.Synapse: The Synapse object representing the preprocessed state of the request.
        The preprocessing involves:
        1. Extracting the request name from the URL path.
        2. Creating a Synapse instance from the request headers using the appropriate class type.
        3. Filling in the Axon and Dendrite information into the Synapse object.
        4. Signing the Synapse from the Axon side using the wallet hotkey.
        This method sets the foundation for the subsequent steps in the request handling process,
        ensuring that all necessary information is encapsulated within the Synapse object.
        &#34;&#34;&#34;
        # Extracts the request name from the URL path.
        try:
            request_name = request.url.path.split(&#34;/&#34;)[1]
        except:
            raise InvalidRequestNameError(
                f&#34;Improperly formatted request. Could not parser request {request.url.path}.&#34;
            )

        # Creates a synapse instance from the headers using the appropriate forward class type
        # based on the request name obtained from the URL path.
        request_synapse = self.axon.forward_class_types.get(request_name)
        if request_synapse is None:
            raise UnknownSynapseError(
                f&#34;Synapse name &#39;{request_name}&#39; not found. Available synapses {list(self.axon.forward_class_types.keys())}&#34;
            )

        try:
            synapse = request_synapse.from_headers(request.headers)  # type: ignore
        except Exception as e:
            raise SynapseParsingError(
                f&#34;Improperly formatted request. Could not parse headers {request.headers} into synapse of type {request_name}.&#34;
            )
        synapse.name = request_name

        # Fills the local axon information into the synapse.
        synapse.axon.__dict__.update(
            {
                &#34;version&#34;: str(cybertensor.__version_as_int__),
                &#34;uuid&#34;: str(self.axon.uuid),
                &#34;nonce&#34;: f&#34;{time.monotonic_ns()}&#34;,
                &#34;status_message&#34;: &#34;Success&#34;,
                &#34;status_code&#34;: &#34;100&#34;,
            }
        )

        # Fills the dendrite information into the synapse.
        synapse.dendrite.__dict__.update(
            {&#34;port&#34;: str(request.client.port), &#34;ip&#34;: str(request.client.host)}  # type: ignore
        )

        # Signs the synapse from the axon side using the wallet hotkey.
        message = f&#34;{synapse.axon.nonce}.{synapse.dendrite.hotkey}.{synapse.axon.hotkey}.{synapse.axon.uuid}&#34;
        synapse.axon.signature = f&#34;0x{self.axon.wallet.hotkey.sign(message).hex()}&#34;

        # Return the setup synapse.
        return synapse

    async def verify(self, synapse: cybertensor.Synapse):
        &#34;&#34;&#34;
        Verifies the authenticity and integrity of the request. This method ensures that the incoming
        request meets the predefined security and validation criteria.
        Args:
            synapse (cybertensor.Synapse): The Synapse object representing the request.
        Raises:
            Exception: If the verification process fails due to unmet criteria or security concerns.
        The verification process involves:
        1. Retrieving the specific verification function for the request&#39;s Synapse type.
        2. Executing the verification function and handling any exceptions that arise.
        Successful verification allows the request to proceed further in the processing pipeline, while
        failure results in an appropriate exception being raised.
        &#34;&#34;&#34;
        # Start of the verification process. Verification is the process where we ensure that
        # the incoming request is from a trusted source or fulfills certain requirements.
        # We get a specific verification function from &#39;verify_fns&#39; dictionary that corresponds
        # to our request&#39;s name. Each request name (synapse name) has its unique verification function.
        verify_fn = (
            self.axon.verify_fns.get(synapse.name) if synapse.name is not None else None
        )

        # If a verification function exists for the request&#39;s name
        if verify_fn:
            try:
                # We attempt to run the verification function using the synapse instance
                # created from the request. If this function runs without throwing an exception,
                # it means that the verification was successful.
                (
                    await verify_fn(synapse)
                    if inspect.iscoroutinefunction(verify_fn)
                    else verify_fn(synapse)
                )
            except Exception as e:
                # If there was an exception during the verification process, we log that
                # there was a verification exception.
                cybertensor.logging.trace(f&#34;Verify exception {str(e)}&#34;)

                # Check if the synapse.axon object exists
                if synapse.axon is not None:
                    # We set the status code of the synapse to &#34;401&#34; which denotes an unauthorized access.
                    synapse.axon.status_code = 401
                else:
                    # If the synapse.axon object doesn&#39;t exist, raise an exception.
                    raise Exception(&#34;Synapse.axon object is None&#34;)

                # We raise an exception to stop the process and return the error to the requester.
                # The error message includes the original exception message.
                raise NotVerifiedException(f&#34;Not Verified with error: {str(e)}&#34;)

    async def blacklist(self, synapse: cybertensor.Synapse):
        &#34;&#34;&#34;
        Checks if the request should be blacklisted. This method ensures that requests from disallowed
        sources or with malicious intent are blocked from processing. This can be extremely useful for
        preventing spam or other forms of abuse. The blacklist is a list of keys or identifiers that
        are prohibited from accessing certain resources.
        Args:
            synapse (cybertensor.Synapse): The Synapse object representing the request.
        Raises:
            Exception: If the request is found in the blacklist.
        The blacklist check involves:
        1. Retrieving the blacklist checking function for the request&#39;s Synapse type.
        2. Executing the check and handling the case where the request is blacklisted.
        If a request is blacklisted, it is blocked, and an exception is raised to halt further processing.
        &#34;&#34;&#34;
        # A blacklist is a list of keys or identifiers
        # that are prohibited from accessing certain resources.
        # We retrieve the blacklist checking function from the &#39;blacklist_fns&#39; dictionary
        # that corresponds to the request&#39;s name (synapse name).
        blacklist_fn = (
            self.axon.blacklist_fns.get(synapse.name)
            if synapse.name is not None
            else None
        )

        # If a blacklist checking function exists for the request&#39;s name
        if blacklist_fn:
            # We execute the blacklist checking function using the synapse instance as input.
            # If the function returns True, it means that the key or identifier is blacklisted.
            blacklisted, reason = (
                await blacklist_fn(synapse)
                if inspect.iscoroutinefunction(blacklist_fn)
                else blacklist_fn(synapse)
            )
            if blacklisted:
                # We log that the key or identifier is blacklisted.
                cybertensor.logging.trace(f&#34;Blacklisted: {blacklisted}, {reason}&#34;)

                # Check if the synapse.axon object exists
                if synapse.axon is not None:
                    # We set the status code of the synapse to &#34;403&#34; which indicates a forbidden access.
                    synapse.axon.status_code = 403
                else:
                    # If the synapse.axon object doesn&#39;t exist, raise an exception.
                    raise Exception(&#34;Synapse.axon object is None&#34;)

                # We raise an exception to halt the process and return the error message to the requester.
                raise BlacklistedException(f&#34;Forbidden. Key is blacklisted: {reason}.&#34;)

    async def priority(self, synapse: cybertensor.Synapse):
        &#34;&#34;&#34;
        Executes the priority function for the request. This method assesses and assigns a priority
        level to the request, determining its urgency and importance in the processing queue.
        Args:
            synapse (cybertensor.Synapse): The Synapse object representing the request.
        Raises:
            Exception: If the priority assessment process encounters issues, such as timeouts.
        The priority function plays a crucial role in managing the processing load and ensuring that
        critical requests are handled promptly.
        &#34;&#34;&#34;
        # Retrieve the priority function from the &#39;priority_fns&#39; dictionary that corresponds
        # to the request&#39;s name (synapse name).
        priority_fn = self.axon.priority_fns.get(str(synapse.name), None)

        async def submit_task(
            executor: PriorityThreadPoolExecutor, priority: float
        ) -&gt; Tuple[float, Any]:
            &#34;&#34;&#34;
            Submits the given priority function to the specified executor for asynchronous execution.
            The function will run in the provided executor and return the priority value along with the result.

            Args:
                executor: The executor in which the priority function will be run.
                priority: The priority function to be executed.

            Returns:
                tuple: A tuple containing the priority value and the result of the priority function execution.
            &#34;&#34;&#34;
            loop = asyncio.get_event_loop()
            future = loop.run_in_executor(executor, lambda: priority)
            result = await future
            return priority, result

        # If a priority function exists for the request&#39;s name
        if priority_fn:
            try:
                # Execute the priority function and get the priority value.
                priority = (
                    await priority_fn(synapse)
                    if inspect.iscoroutinefunction(priority_fn)
                    else priority_fn(synapse)
                )

                # Submit the task to the thread pool for execution with the given priority.
                # The submit_task function will handle the execution and return the result.
                _, result = await submit_task(self.axon.thread_pool, priority)

            except TimeoutError as e:
                # If the execution of the priority function exceeds the timeout,
                # it raises an exception to handle the timeout error.
                cybertensor.logging.trace(f&#34;TimeoutError: {str(e)}&#34;)

                # Set the status code of the synapse to 408 which indicates a timeout error.
                if synapse.axon is not None:
                    synapse.axon.status_code = 408

                # Raise an exception to stop the process and return an appropriate error message to the requester.
                raise PriorityException(f&#34;Response timeout after: {synapse.timeout}s&#34;)

    async def run(
        self,
        synapse: cybertensor.Synapse,
        call_next: RequestResponseEndpoint,
        request: Request,
    ) -&gt; Response:
        &#34;&#34;&#34;
        Executes the requested function as part of the request processing pipeline. This method calls
        the next function in the middleware chain to process the request and generate a response.
        Args:
            synapse (cybertensor.Synapse): The Synapse object representing the request.
            call_next (RequestResponseEndpoint): The next function in the middleware chain to process requests.
            request (Request): The original HTTP request.
        Returns:
            Response: The HTTP response generated by processing the request.
        This method is a critical part of the request lifecycle, where the actual processing of the
        request takes place, leading to the generation of a response.
        &#34;&#34;&#34;
        try:
            # The requested function is executed by calling the &#39;call_next&#39; function,
            # passing the original request as an argument. This function processes the request
            # and returns the response.
            response = await call_next(request)

        except Exception as e:
            # If an exception occurs during the execution of the requested function,
            # it is caught and handled here.

            # Log the exception for debugging purposes.
            cybertensor.logging.trace(f&#34;Run exception: {str(e)}&#34;)

            # Set the status code of the synapse to &#34;500&#34; which indicates an internal server error.
            if synapse.axon is not None:
                synapse.axon.status_code = 500

            # Raise an exception to stop the process and return an appropriate error message to the requester.
            raise RunException(f&#34;Internal server error with error: {str(e)}&#34;)

        # Return the starlet response
        return response

    async def postprocess(
        self, synapse: cybertensor.Synapse, response: Response, start_time: float
    ) -&gt; Response:
        &#34;&#34;&#34;
        Performs the final processing on the response before sending it back to the client. This method
        updates the response headers and logs the end of the request processing.
        Args:
            synapse (cybertensor.Synapse): The Synapse object representing the request.
            response (Response): The response generated by processing the request.
            start_time (float): The timestamp when the request processing started.
        Returns:
            Response: The final HTTP response, with updated headers, ready to be sent back to the client.
        Postprocessing is the last step in the request handling process, ensuring that the response is
        properly formatted and contains all necessary information.
        &#34;&#34;&#34;
        # Set the status code of the synapse to &#34;200&#34; which indicates a successful response.
        if synapse.axon is not None:
            synapse.axon.status_code = 200

            # Set the status message of the synapse to &#34;Success&#34;.
            synapse.axon.status_message = &#34;Success&#34;

        try:
            # Update the response headers with the headers from the synapse.
            updated_headers = synapse.to_headers()
            response.headers.update(updated_headers)
        except Exception as e:
            # If there is an exception during the response header update, we log the exception.
            raise PostProcessException(
                f&#34;Error while parsing or updating response headers. Postprocess exception: {str(e)}.&#34;
            )

        # Calculate the processing time by subtracting the start time from the current time.
        synapse.axon.process_time = str(time.time() - start_time)  # type: ignore

        return response</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>starlette.middleware.base.BaseHTTPMiddleware</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cybertensor.axon.AxonMiddleware.blacklist"><code class="name flex">
<span>async def <span class="ident">blacklist</span></span>(<span>self, synapse: <a title="cybertensor.synapse.Synapse" href="synapse.html#cybertensor.synapse.Synapse">Synapse</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the request should be blacklisted. This method ensures that requests from disallowed
sources or with malicious intent are blocked from processing. This can be extremely useful for
preventing spam or other forms of abuse. The blacklist is a list of keys or identifiers that
are prohibited from accessing certain resources.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>synapse</code></strong> :&ensp;<code>cybertensor.Synapse</code></dt>
<dd>The Synapse object representing the request.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>If the request is found in the blacklist.</dd>
</dl>
<p>The blacklist check involves:
1. Retrieving the blacklist checking function for the request's Synapse type.
2. Executing the check and handling the case where the request is blacklisted.
If a request is blacklisted, it is blocked, and an exception is raised to halt further processing.</p></div>
</dd>
<dt id="cybertensor.axon.AxonMiddleware.dispatch"><code class="name flex">
<span>async def <span class="ident">dispatch</span></span>(<span>self, request: starlette.requests.Request, call_next: Callable[[starlette.requests.Request], Awaitable[starlette.responses.Response]]) ‑> starlette.responses.Response</span>
</code></dt>
<dd>
<div class="desc"><p>Asynchronously processes incoming HTTP requests and returns the corresponding responses. This
method acts as the central processing unit of the AxonMiddleware, handling each step in the
request lifecycle.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>Request</code></dt>
<dd>The incoming HTTP request to be processed.</dd>
<dt><strong><code>call_next</code></strong> :&ensp;<code>RequestResponseEndpoint</code></dt>
<dd>A callable that processes the request and returns a response.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Response</code></dt>
<dd>The HTTP response generated after processing the request.</dd>
</dl>
<p>This method performs several key functions:
1. Request Preprocessing: Sets up Synapse object from request headers and fills necessary information.
2. Logging: Logs the start of request processing.
3. Blacklist Checking: Verifies if the request is blacklisted.
4. Request Verification: Ensures the authenticity and integrity of the request.
5. Priority Assessment: Evaluates and assigns priority to the request.
6. Request Execution: Calls the next function in the middleware chain to process the request.
7. Response Postprocessing: Updates response headers and logs the end of the request processing.</p>
<p>The method also handles exceptions and errors that might occur during each stage, ensuring that
appropriate responses are returned to the client.</p></div>
</dd>
<dt id="cybertensor.axon.AxonMiddleware.postprocess"><code class="name flex">
<span>async def <span class="ident">postprocess</span></span>(<span>self, synapse: <a title="cybertensor.synapse.Synapse" href="synapse.html#cybertensor.synapse.Synapse">Synapse</a>, response: starlette.responses.Response, start_time: float) ‑> starlette.responses.Response</span>
</code></dt>
<dd>
<div class="desc"><p>Performs the final processing on the response before sending it back to the client. This method
updates the response headers and logs the end of the request processing.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>synapse</code></strong> :&ensp;<code>cybertensor.Synapse</code></dt>
<dd>The Synapse object representing the request.</dd>
<dt><strong><code>response</code></strong> :&ensp;<code>Response</code></dt>
<dd>The response generated by processing the request.</dd>
<dt><strong><code>start_time</code></strong> :&ensp;<code>float</code></dt>
<dd>The timestamp when the request processing started.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Response</code></dt>
<dd>The final HTTP response, with updated headers, ready to be sent back to the client.</dd>
</dl>
<p>Postprocessing is the last step in the request handling process, ensuring that the response is
properly formatted and contains all necessary information.</p></div>
</dd>
<dt id="cybertensor.axon.AxonMiddleware.preprocess"><code class="name flex">
<span>async def <span class="ident">preprocess</span></span>(<span>self, request: starlette.requests.Request) ‑> <a title="cybertensor.synapse.Synapse" href="synapse.html#cybertensor.synapse.Synapse">Synapse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Performs the initial processing of the incoming request. This method is responsible for
extracting relevant information from the request and setting up the Synapse object, which
represents the state and context of the request within the Axon server.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>Request</code></dt>
<dd>The incoming request to be preprocessed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>cybertensor.Synapse</code></dt>
<dd>The Synapse object representing the preprocessed state of the request.</dd>
</dl>
<p>The preprocessing involves:
1. Extracting the request name from the URL path.
2. Creating a Synapse instance from the request headers using the appropriate class type.
3. Filling in the Axon and Dendrite information into the Synapse object.
4. Signing the Synapse from the Axon side using the wallet hotkey.
This method sets the foundation for the subsequent steps in the request handling process,
ensuring that all necessary information is encapsulated within the Synapse object.</p></div>
</dd>
<dt id="cybertensor.axon.AxonMiddleware.priority"><code class="name flex">
<span>async def <span class="ident">priority</span></span>(<span>self, synapse: <a title="cybertensor.synapse.Synapse" href="synapse.html#cybertensor.synapse.Synapse">Synapse</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Executes the priority function for the request. This method assesses and assigns a priority
level to the request, determining its urgency and importance in the processing queue.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>synapse</code></strong> :&ensp;<code>cybertensor.Synapse</code></dt>
<dd>The Synapse object representing the request.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>If the priority assessment process encounters issues, such as timeouts.</dd>
</dl>
<p>The priority function plays a crucial role in managing the processing load and ensuring that
critical requests are handled promptly.</p></div>
</dd>
<dt id="cybertensor.axon.AxonMiddleware.run"><code class="name flex">
<span>async def <span class="ident">run</span></span>(<span>self, synapse: <a title="cybertensor.synapse.Synapse" href="synapse.html#cybertensor.synapse.Synapse">Synapse</a>, call_next: Callable[[starlette.requests.Request], Awaitable[starlette.responses.Response]], request: starlette.requests.Request) ‑> starlette.responses.Response</span>
</code></dt>
<dd>
<div class="desc"><p>Executes the requested function as part of the request processing pipeline. This method calls
the next function in the middleware chain to process the request and generate a response.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>synapse</code></strong> :&ensp;<code>cybertensor.Synapse</code></dt>
<dd>The Synapse object representing the request.</dd>
<dt><strong><code>call_next</code></strong> :&ensp;<code>RequestResponseEndpoint</code></dt>
<dd>The next function in the middleware chain to process requests.</dd>
<dt><strong><code>request</code></strong> :&ensp;<code>Request</code></dt>
<dd>The original HTTP request.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Response</code></dt>
<dd>The HTTP response generated by processing the request.</dd>
</dl>
<p>This method is a critical part of the request lifecycle, where the actual processing of the
request takes place, leading to the generation of a response.</p></div>
</dd>
<dt id="cybertensor.axon.AxonMiddleware.verify"><code class="name flex">
<span>async def <span class="ident">verify</span></span>(<span>self, synapse: <a title="cybertensor.synapse.Synapse" href="synapse.html#cybertensor.synapse.Synapse">Synapse</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Verifies the authenticity and integrity of the request. This method ensures that the incoming
request meets the predefined security and validation criteria.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>synapse</code></strong> :&ensp;<code>cybertensor.Synapse</code></dt>
<dd>The Synapse object representing the request.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>If the verification process fails due to unmet criteria or security concerns.</dd>
</dl>
<p>The verification process involves:
1. Retrieving the specific verification function for the request's Synapse type.
2. Executing the verification function and handling any exceptions that arise.
Successful verification allows the request to proceed further in the processing pipeline, while
failure results in an appropriate exception being raised.</p></div>
</dd>
</dl>
</dd>
<dt id="cybertensor.axon.FastAPIThreadedServer"><code class="flex name class">
<span>class <span class="ident">FastAPIThreadedServer</span></span>
<span>(</span><span>config: uvicorn.config.Config)</span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="cybertensor.axon.FastAPIThreadedServer" href="#cybertensor.axon.FastAPIThreadedServer">FastAPIThreadedServer</a></code> class is a specialized server implementation for the Axon server in the cybertensor network.
It extends the functionality of :func:<code>uvicorn.Server</code> to run the FastAPI application in a separate thread, allowing
the Axon server to handle HTTP requests concurrently and non-blocking.
This class is designed to facilitate the integration of FastAPI with the Axon's asynchronous architecture, ensuring
efficient and scalable handling of network requests.
Importance and Functionality
Threaded Execution
The class allows the FastAPI application to run in a separate thread, enabling concurrent handling of HTTP
requests which is crucial for the performance and scalability of the Axon server.
Seamless Integration
By running FastAPI in a threaded manner, this class ensures seamless integration of FastAPI's capabilities
with the Axon server's asynchronous and multi-threaded architecture.
Controlled Server Management
The methods start and stop provide controlled management of the server's lifecycle, ensuring that the server
can be started and stopped as needed, which is vital for maintaining the Axon server's reliability and
availability.
Signal Handling
Overriding the default signal handlers prevents potential conflicts with the Axon server's main application
flow, ensuring stable operation in various network conditions.
Use Cases
Starting the Server
When the Axon server is initialized, it can use this class to start the FastAPI application in a separate
thread, enabling it to begin handling HTTP requests immediately.
Stopping the Server
During shutdown or maintenance of the Axon server, this class can be used to stop the FastAPI application
gracefully, ensuring that all resources are properly released.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>should_exit</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag to indicate whether the server should stop running.</dd>
<dt><strong><code>is_running</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag to indicate whether the server is currently running.</dd>
</dl>
<p>The server overrides the default signal handlers to prevent interference with the main application flow and provides
methods to start and stop the server in a controlled manner.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FastAPIThreadedServer(uvicorn.Server):
    &#34;&#34;&#34;
    The ``FastAPIThreadedServer`` class is a specialized server implementation for the Axon server in the cybertensor network.
    It extends the functionality of :func:`uvicorn.Server` to run the FastAPI application in a separate thread, allowing
    the Axon server to handle HTTP requests concurrently and non-blocking.
    This class is designed to facilitate the integration of FastAPI with the Axon&#39;s asynchronous architecture, ensuring
    efficient and scalable handling of network requests.
    Importance and Functionality
        Threaded Execution
            The class allows the FastAPI application to run in a separate thread, enabling concurrent handling of HTTP
            requests which is crucial for the performance and scalability of the Axon server.
        Seamless Integration
            By running FastAPI in a threaded manner, this class ensures seamless integration of FastAPI&#39;s capabilities
            with the Axon server&#39;s asynchronous and multi-threaded architecture.
        Controlled Server Management
            The methods start and stop provide controlled management of the server&#39;s lifecycle, ensuring that the server
            can be started and stopped as needed, which is vital for maintaining the Axon server&#39;s reliability and
            availability.
        Signal Handling
            Overriding the default signal handlers prevents potential conflicts with the Axon server&#39;s main application
            flow, ensuring stable operation in various network conditions.
    Use Cases
        Starting the Server
            When the Axon server is initialized, it can use this class to start the FastAPI application in a separate
            thread, enabling it to begin handling HTTP requests immediately.
        Stopping the Server
            During shutdown or maintenance of the Axon server, this class can be used to stop the FastAPI application
            gracefully, ensuring that all resources are properly released.
    Args:
        should_exit (bool): Flag to indicate whether the server should stop running.
        is_running (bool): Flag to indicate whether the server is currently running.

    The server overrides the default signal handlers to prevent interference with the main application flow and provides
    methods to start and stop the server in a controlled manner.
    &#34;&#34;&#34;
    should_exit: bool = False
    is_running: bool = False

    def install_signal_handlers(self):
        &#34;&#34;&#34;
        Overrides the default signal handlers provided by ``uvicorn.Server``. This method is essential to ensure that
        the signal handling in the threaded server does not interfere with the main application&#39;s flow, especially in
        a complex asynchronous environment like the Axon server.
        &#34;&#34;&#34;
        pass

    @contextlib.contextmanager
    def run_in_thread(self):
        &#34;&#34;&#34;
        Manages the execution of the server in a separate thread, allowing the FastAPI application to run asynchronously
        without blocking the main thread of the Axon server. This method is a key component in enabling concurrent
        request handling in the Axon server.
        Yields:
            None: This method yields control back to the caller while the server is running in the background thread.
        &#34;&#34;&#34;
        thread = threading.Thread(target=self.run, daemon=True)
        thread.start()
        try:
            while not self.started:
                time.sleep(1e-3)
            yield
        finally:
            self.should_exit = True
            thread.join()

    def _wrapper_run(self):
        &#34;&#34;&#34;
        A wrapper method for the :func:`run_in_thread` context manager. This method is used internally by the ``start``
        method to initiate the server&#39;s execution in a separate thread.
        &#34;&#34;&#34;
        with self.run_in_thread():
            while not self.should_exit:
                time.sleep(1e-3)

    def start(self):
        &#34;&#34;&#34;
        Starts the FastAPI server in a separate thread if it is not already running. This method sets up the server to
        handle HTTP requests concurrently, enabling the Axon server to efficiently manage incoming network requests.
        The method ensures that the server starts running in a non-blocking manner, allowing the Axon server to
        continue its other operations seamlessly.
        &#34;&#34;&#34;
        if not self.is_running:
            self.should_exit = False
            thread = threading.Thread(target=self._wrapper_run, daemon=True)
            thread.start()
            self.is_running = True

    def stop(self):
        &#34;&#34;&#34;
        Signals the FastAPI server to stop running. This method sets the :func:`should_exit` flag to ``True``,
        indicating that the server should cease its operations and exit the running thread.
        Stopping the server is essential for controlled shutdowns and resource management in the Axon server,
        especially during maintenance or when redeploying with updated configurations.
        &#34;&#34;&#34;
        if self.is_running:
            self.should_exit = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>uvicorn.server.Server</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="cybertensor.axon.FastAPIThreadedServer.is_running"><code class="name">var <span class="ident">is_running</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cybertensor.axon.FastAPIThreadedServer.should_exit"><code class="name">var <span class="ident">should_exit</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="cybertensor.axon.FastAPIThreadedServer.install_signal_handlers"><code class="name flex">
<span>def <span class="ident">install_signal_handlers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Overrides the default signal handlers provided by <code>uvicorn.Server</code>. This method is essential to ensure that
the signal handling in the threaded server does not interfere with the main application's flow, especially in
a complex asynchronous environment like the Axon server.</p></div>
</dd>
<dt id="cybertensor.axon.FastAPIThreadedServer.run_in_thread"><code class="name flex">
<span>def <span class="ident">run_in_thread</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manages the execution of the server in a separate thread, allowing the FastAPI application to run asynchronously
without blocking the main thread of the Axon server. This method is a key component in enabling concurrent
request handling in the Axon server.</p>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>None</code></dt>
<dd>This method yields control back to the caller while the server is running in the background thread.</dd>
</dl></div>
</dd>
<dt id="cybertensor.axon.FastAPIThreadedServer.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts the FastAPI server in a separate thread if it is not already running. This method sets up the server to
handle HTTP requests concurrently, enabling the Axon server to efficiently manage incoming network requests.
The method ensures that the server starts running in a non-blocking manner, allowing the Axon server to
continue its other operations seamlessly.</p></div>
</dd>
<dt id="cybertensor.axon.FastAPIThreadedServer.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Signals the FastAPI server to stop running. This method sets the :func:<code>should_exit</code> flag to <code>True</code>,
indicating that the server should cease its operations and exit the running thread.
Stopping the server is essential for controlled shutdowns and resource management in the Axon server,
especially during maintenance or when redeploying with updated configurations.</p></div>
</dd>
</dl>
</dd>
<dt id="cybertensor.axon.axon"><code class="flex name class">
<span>class <span class="ident">axon</span></span>
<span>(</span><span>wallet: Optional[ForwardRef('Wallet')] = None, config: Optional[ForwardRef('Config')] = None, port: Optional[int] = None, ip: Optional[str] = None, external_ip: Optional[str] = None, external_port: Optional[int] = None, max_workers: Optional[int] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="cybertensor.axon.axon" href="#cybertensor.axon.axon">axon</a></code> class in cybertensor is a fundamental component that serves as the server-side interface for a neuron
within the cybertensor network.
This class is responsible for managing incoming requests from other neurons and implements various mechanisms to
ensure efficient and secure network interactions.
An axon relies on a FastAPI router to create endpoints for different message types. These endpoints are crucial for
handling various request types that a neuron might receive. The class is designed to be flexible and customizable,
allowing users to specify custom rules for forwarding, blacklisting, prioritizing, and verifying incoming requests.
The class also includes internal mechanisms to manage a thread pool, supporting concurrent handling of requests with
defined priority levels.</p>
<p>Methods in this class are equipped to deal with incoming requests from various scenarios in the network and serve as
the server face for a neuron. It accepts multiple arguments, like wallet, configuration parameters, ip address,
server binding
port, external ip, external port and max workers. Key methods involve managing and operating the
FastAPI application router, including the attachment and operation of endpoints.</p>
<p>Key Features:
- FastAPI router integration for endpoint creation and management.
- Customizable request handling including forwarding, blacklisting, and prioritization.
- Verification of incoming requests against custom-defined functions.
- Thread pool management for concurrent request handling.
- Command-line argument support for user-friendly program interaction.</p>
<p>Example usage::</p>
<pre><code> import cybertensor
 # Define your custom synapse class
 class MySynapse( cybertensor.Synapse ):
     input: int = 1
     output: int = None

 # Define a custom request forwarding function
 def forward_my_synapse( synapse: MySynapse ) -&gt; MySynapse:
     # Apply custom logic to synapse and return it
     synapse.output = 2
     return synapse

 # Define a custom request verification function
 def verify_my_synapse( synapse: MySynapse ):
     # Apply custom verification logic to synapse
     # Optionally raise Exception

 # Define a custom request blacklist function
 def blacklist_my_synapse( synapse: MySynapse ) -&gt; bool:
     # Apply custom blacklist
     # return False ( if non blacklisted ) or True ( if blacklisted )

 # Define a custom request priority function
 def prioritize_my_synapse( synapse: MySynapse ) -&gt; float:
     # Apply custom priority
     return 1.0

 # Initialize Axon object with a custom configuration
 my_axon = cybertensor.axon(config=my_config, wallet=my_wallet, port=9090, ip="192.0.2.0", external_ip="203.0.113.0", external_port=7070)

 # Attach the endpoint with the specified verification and forwarding functions
 my_axon.attach(
     forward_fn = forward_my_synapse,
     verify_fn = verify_my_synapse,
     blacklist_fn = blacklist_my_synapse,
     priority_fn = prioritize_my_synapse
 ).attach(
     forward_fn = forward_my_synapse_2,
     verify_fn = verify_my_synapse_2,
     blacklist_fn = blacklist_my_synapse_2,
     priority_fn = prioritize_my_synapse_2
 ).serve(
     netuid = ...
     cwtensor = ...
 ).start()
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wallet</code></strong> :&ensp;<code><a title="cybertensor.wallet" href="wallet.html">cybertensor.wallet</a></code>, optional</dt>
<dd>Wallet with hotkey and coldkeypub.</dd>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="cybertensor.config" href="config.html">cybertensor.config</a></code>, optional</dt>
<dd>Configuration parameters for the axon.</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Port for server binding.</dd>
<dt><strong><code>ip</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Binding IP address.</dd>
<dt><strong><code>external_ip</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>External IP address to broadcast.</dd>
<dt><strong><code>external_port</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>External port to broadcast.</dd>
<dt><strong><code>max_workers</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of active threads for request handling.</dd>
</dl>
<p>Returns:
cybertensor.axon: An instance of the axon class configured as per the provided arguments.
Note:
This class is a core part of cybertensor's decentralized network for machine intelligence,
allowing neurons to communicate effectively and securely.
Importance and Functionality
Endpoint Registration
This method dynamically registers API endpoints based on the Synapse used, allowing the Axon to respond to
specific types of requests and synapses.
Customization of Request Handling
By attaching different functions, the Axon can customize how it
handles, verifies, prioritizes, and potentially blocks incoming requests, making it adaptable to various
network scenarios.
Security and Efficiency
The method contributes to both the security (via verification and blacklisting) and efficiency (via
prioritization) of request handling, which are crucial in a decentralized network environment.
Flexibility
The ability to define custom functions for different aspects of request handling provides great flexibility,
allowing the Axon to be tailored to specific needs and use cases within the cybertensor network.
Error Handling and Validation
The method ensures that the attached functions meet the required
signatures, providing error handling to prevent runtime issues.</p>
<p>Creates a new cybertensor.Axon object from passed arguments.</p>
<h2 id="args_1">Args</h2>
<p>config (:obj:<code>Optional[Config]</code>, <code>optional</code>):
cybertensor.axon.config()
wallet (:obj:<code>Optional[Wallet]</code>, <code>optional</code>):
cybertensor wallet with hotkey and coldkeypub.
port (:type:<code>Optional[int]</code>, <code>optional</code>):
Binding port.
ip (:type:<code>Optional[str]</code>, <code>optional</code>):
Binding ip.
external_ip (:type:<code>Optional[str]</code>, <code>optional</code>):
The external ip of the server to broadcast to the network.
external_port (:type:<code>Optional[int]</code>, <code>optional</code>):
The external port of the server to broadcast to the network.
max_workers (:type:<code>Optional[int]</code>, <code>optional</code>):
Used to create the threadpool if not passed, specifies the number of active threads servicing requests.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class axon:
    &#34;&#34;&#34;
    The ``axon`` class in cybertensor is a fundamental component that serves as the server-side interface for a neuron 
    within the cybertensor network.
    This class is responsible for managing incoming requests from other neurons and implements various mechanisms to 
    ensure efficient and secure network interactions.
    An axon relies on a FastAPI router to create endpoints for different message types. These endpoints are crucial for 
    handling various request types that a neuron might receive. The class is designed to be flexible and customizable, 
    allowing users to specify custom rules for forwarding, blacklisting, prioritizing, and verifying incoming requests. 
    The class also includes internal mechanisms to manage a thread pool, supporting concurrent handling of requests with 
    defined priority levels.
    
    Methods in this class are equipped to deal with incoming requests from various scenarios in the network and serve as 
    the server face for a neuron. It accepts multiple arguments, like wallet, configuration parameters, ip address, 
    server binding  port, external ip, external port and max workers. Key methods involve managing and operating the 
    FastAPI application router, including the attachment and operation of endpoints.
    
    Key Features:
    - FastAPI router integration for endpoint creation and management.
    - Customizable request handling including forwarding, blacklisting, and prioritization.
    - Verification of incoming requests against custom-defined functions.
    - Thread pool management for concurrent request handling.
    - Command-line argument support for user-friendly program interaction.

    Example usage::

        import cybertensor
        # Define your custom synapse class
        class MySynapse( cybertensor.Synapse ):
            input: int = 1
            output: int = None

        # Define a custom request forwarding function
        def forward_my_synapse( synapse: MySynapse ) -&gt; MySynapse:
            # Apply custom logic to synapse and return it
            synapse.output = 2
            return synapse

        # Define a custom request verification function
        def verify_my_synapse( synapse: MySynapse ):
            # Apply custom verification logic to synapse
            # Optionally raise Exception

        # Define a custom request blacklist function
        def blacklist_my_synapse( synapse: MySynapse ) -&gt; bool:
            # Apply custom blacklist
            # return False ( if non blacklisted ) or True ( if blacklisted )

        # Define a custom request priority function
        def prioritize_my_synapse( synapse: MySynapse ) -&gt; float:
            # Apply custom priority
            return 1.0

        # Initialize Axon object with a custom configuration
        my_axon = cybertensor.axon(config=my_config, wallet=my_wallet, port=9090, ip=&#34;192.0.2.0&#34;, external_ip=&#34;203.0.113.0&#34;, external_port=7070)

        # Attach the endpoint with the specified verification and forwarding functions
        my_axon.attach(
            forward_fn = forward_my_synapse,
            verify_fn = verify_my_synapse,
            blacklist_fn = blacklist_my_synapse,
            priority_fn = prioritize_my_synapse
        ).attach(
            forward_fn = forward_my_synapse_2,
            verify_fn = verify_my_synapse_2,
            blacklist_fn = blacklist_my_synapse_2,
            priority_fn = prioritize_my_synapse_2
        ).serve(
            netuid = ...
            cwtensor = ...
        ).start()

   Args:
        wallet (cybertensor.wallet, optional): Wallet with hotkey and coldkeypub.
        config (cybertensor.config, optional): Configuration parameters for the axon.
        port (int, optional): Port for server binding.
        ip (str, optional): Binding IP address.
        external_ip (str, optional): External IP address to broadcast.
        external_port (int, optional): External port to broadcast.
        max_workers (int, optional): Number of active threads for request handling.
    Returns:
        cybertensor.axon: An instance of the axon class configured as per the provided arguments.
    Note:
        This class is a core part of cybertensor&#39;s decentralized network for machine intelligence,
        allowing neurons to communicate effectively and securely.
    Importance and Functionality
        Endpoint Registration
            This method dynamically registers API endpoints based on the Synapse used, allowing the Axon to respond to 
            specific types of requests and synapses.
        Customization of Request Handling
            By attaching different functions, the Axon can customize how it
            handles, verifies, prioritizes, and potentially blocks incoming requests, making it adaptable to various 
            network scenarios.
        Security and Efficiency
            The method contributes to both the security (via verification and blacklisting) and efficiency (via 
            prioritization) of request handling, which are crucial in a decentralized network environment.
        Flexibility
            The ability to define custom functions for different aspects of request handling provides great flexibility, 
            allowing the Axon to be tailored to specific needs and use cases within the cybertensor network.
        Error Handling and Validation
            The method ensures that the attached functions meet the required
            signatures, providing error handling to prevent runtime issues.
    &#34;&#34;&#34;

    def __init__(
        self,
        wallet: Optional[&#34;Wallet&#34;] = None,
        config: Optional[&#34;Config&#34;] = None,
        port: Optional[int] = None,
        ip: Optional[str] = None,
        external_ip: Optional[str] = None,
        external_port: Optional[int] = None,
        max_workers: Optional[int] = None,
    ):
        r&#34;&#34;&#34;Creates a new cybertensor.Axon object from passed arguments.
        Args:
            config (:obj:`Optional[Config]`, `optional`):
                cybertensor.axon.config()
            wallet (:obj:`Optional[Wallet]`, `optional`):
                cybertensor wallet with hotkey and coldkeypub.
            port (:type:`Optional[int]`, `optional`):
                Binding port.
            ip (:type:`Optional[str]`, `optional`):
                Binding ip.
            external_ip (:type:`Optional[str]`, `optional`):
                The external ip of the server to broadcast to the network.
            external_port (:type:`Optional[int]`, `optional`):
                The external port of the server to broadcast to the network.
            max_workers (:type:`Optional[int]`, `optional`):
                Used to create the threadpool if not passed, specifies the number of active threads servicing requests.
        &#34;&#34;&#34;
        # Build and check config.
        if config is None:
            config = axon.config()
        config = copy.deepcopy(config)
        config.axon.ip = ip or config.axon.get(&#34;ip&#34;, cybertensor.defaults.axon.ip)
        config.axon.port = port or config.axon.get(
            &#34;port&#34;, cybertensor.defaults.axon.port
        )
        config.axon.external_ip = external_ip or config.axon.get(
            &#34;external_ip&#34;, cybertensor.defaults.axon.external_ip
        )
        config.axon.external_port = external_port or config.axon.get(
            &#34;external_port&#34;, cybertensor.defaults.axon.external_port
        )
        config.axon.max_workers = max_workers or config.axon.get(
            &#34;max_workers&#34;, cybertensor.defaults.axon.max_workers
        )
        axon.check_config(config)
        self.config = config

        # Get wallet or use default.
        self.wallet = wallet or Wallet()

        # Build axon objects.
        self.uuid = str(uuid.uuid1())
        self.ip = self.config.axon.ip
        self.port = self.config.axon.port
        self.external_ip = self.config.axon.external_ip or net.get_external_ip()
        self.external_port = self.config.axon.external_port or self.config.axon.port
        self.full_address = str(self.config.axon.ip) + &#34;:&#34; + str(self.config.axon.port)
        self.started = False

        # Build middleware
        self.thread_pool = cybertensor.PriorityThreadPoolExecutor(
            max_workers=self.config.axon.max_workers
        )
        self.nonces = {}

        # Request default functions.
        self.forward_class_types = {}
        self.blacklist_fns = {}
        self.priority_fns = {}
        self.forward_fns = {}
        self.verify_fns = {}
        self.required_hash_fields = {}

        # Instantiate FastAPI
        self.app = FastAPI()
        log_level = &#34;trace&#34; if cybertensor.logging.__trace_on__ else &#34;critical&#34;
        self.fast_config = uvicorn.Config(
            self.app, host=&#34;0.0.0.0&#34;, port=self.config.axon.port, log_level=log_level
        )
        self.fast_server = FastAPIThreadedServer(config=self.fast_config)
        self.router = APIRouter()
        self.app.include_router(self.router)

        # Build ourselves as the middleware.
        self.app.add_middleware(AxonMiddleware, axon=self)

        # Attach default forward.
        def ping(r: cybertensor.Synapse) -&gt; cybertensor.Synapse:
            return r

        self.attach(
            forward_fn=ping, verify_fn=None, blacklist_fn=None, priority_fn=None
        )

    def info(self) -&gt; &#34;cybertensor.AxonInfo&#34;:
        &#34;&#34;&#34;Returns the axon info object associated with this axon.&#34;&#34;&#34;
        return cybertensor.AxonInfo(
            version=cybertensor.__version_as_int__,
            ip=self.external_ip,
            ip_type=4,
            port=self.external_port,
            hotkey=self.wallet.hotkey.address,
            coldkey=self.wallet.coldkeypub.address,
            protocol=4,
            placeholder1=0,
            placeholder2=0,
        )

    def attach(
        self,
        forward_fn: Callable,
        blacklist_fn: Optional[Callable] = None,
        priority_fn: Optional[Callable] = None,
        verify_fn: Optional[Callable] = None,
    ) -&gt; &#34;cybertensor.axon&#34;:
        &#34;&#34;&#34;
        Attaches custom functions to the Axon server for handling incoming requests. This method enables
        the Axon to define specific behaviors for request forwarding, verification, blacklisting, and
        prioritization, thereby customizing its interaction within the cybertensor network.
        Registers an API endpoint to the FastAPI application router.
        It uses the name of the first argument of the :func:`forward_fn` function as the endpoint name.
        The attach method in the cybertensor framework&#39;s axon class is a crucial function for registering
        API endpoints to the Axon&#39;s FastAPI application router. This method allows the Axon server to
        define how it handles incoming requests by attaching functions for forwarding, verifying,
        blacklisting, and prioritizing requests. It&#39;s a key part of customizing the server&#39;s behavior
        and ensuring efficient and secure handling of requests within the cybertensor network.
        Args:
            forward_fn (Callable): Function to be called when the API endpoint is accessed. It should have at least one
                argument.
            blacklist_fn (Callable, optional): Function to filter out undesired requests. It should take the same
                arguments as :func:`forward_fn` and return a boolean value. Defaults to ``None``, meaning no blacklist
                filter will be used.
            priority_fn (Callable, optional): Function to rank requests based on their priority. It should take the same
                arguments as :func:`forward_fn` and return a numerical value representing the request&#39;s priority.
                Defaults to ``None``, meaning no priority sorting will be applied.
            verify_fn (Callable, optional): Function to verify requests. It should take the same arguments as
                :func:`forward_fn` and return a boolean value. If ``None``, :func:`self.default_verify` function will be used.
        Note:
            The methods :func:`forward_fn`, :func:`blacklist_fn`, :func:`priority_fn`, and :func:`verify_fn` should be
            designed to receive the same parameters.
        Raises:
            AssertionError: If :func:`forward_fn` does not have the signature: ``forward( synapse: YourSynapse ) -&gt; synapse``.
            AssertionError: If :func:`blacklist_fn` does not have the signature: ``blacklist( synapse: YourSynapse ) -&gt; bool``.
            AssertionError: If :func:`priority_fn` does not have the signature: ``priority( synapse: YourSynapse ) -&gt; float``.
            AssertionError: If :func:`verify_fn` does not have the signature: ``verify( synapse: YourSynapse ) -&gt; None``.
        Returns:
            self: Returns the instance of the AxonServer class for potential method chaining.
        Example Usage::
            def forward_custom(synapse: MyCustomSynapse) -&gt; MyCustomSynapse:
                # Custom logic for processing the request
                return synapse
            def blacklist_custom(synapse: MyCustomSynapse) -&gt; Tuple[bool, str]:
                return True, &#34;Allowed!&#34;
            def priority_custom(synapse: MyCustomSynapse) -&gt; float:
                return 1.0
            def verify_custom(synapse: MyCustomSynapse):
                # Custom logic for verifying the request
                pass
            my_axon = cybertensor.axon(...)
            my_axon.attach(forward_fn=forward_custom, verify_fn=verify_custom)
        Note:
            The :func:`attach` method is fundamental in setting up the Axon server&#39;s request handling capabilities,
            enabling it to participate effectively and securely in the cybertensor network. The flexibility
            offered by this method allows developers to tailor the Axon&#39;s behavior to specific requirements and
            use cases.
        &#34;&#34;&#34;

        # Assert &#39;forward_fn&#39; has exactly one argument
        forward_sig = signature(forward_fn)
        assert (
            len(list(forward_sig.parameters)) == 1
        ), &#34;The passed function must have exactly one argument&#34;

        # Obtain the class of the first argument of &#39;forward_fn&#39;
        request_class = forward_sig.parameters[
            list(forward_sig.parameters)[0]
        ].annotation

        # Assert that the first argument of &#39;forward_fn&#39; is a subclass of &#39;cybertensor.Synapse&#39;
        assert issubclass(
            request_class, cybertensor.Synapse
        ), &#34;The argument of forward_fn must inherit from cybertensor.Synapse&#34;

        # Obtain the class name of the first argument of &#39;forward_fn&#39;
        request_name = forward_sig.parameters[
            list(forward_sig.parameters)[0]
        ].annotation.__name__

        # Add the endpoint to the router, making it available on both GET and POST methods
        self.router.add_api_route(
            f&#34;/{request_name}&#34;,
            forward_fn,
            methods=[&#34;GET&#34;, &#34;POST&#34;],
            dependencies=[Depends(self.verify_body_integrity)],
        )
        self.app.include_router(self.router)

        # Expected signatures for &#39;blacklist_fn&#39;, &#39;priority_fn&#39; and &#39;verify_fn&#39;
        blacklist_sig = Signature(
            [
                Parameter(
                    &#34;synapse&#34;,
                    Parameter.POSITIONAL_OR_KEYWORD,
                    annotation=forward_sig.parameters[
                        list(forward_sig.parameters)[0]
                    ].annotation,
                )
            ],
            return_annotation=Tuple[bool, str],
        )
        priority_sig = Signature(
            [
                Parameter(
                    &#34;synapse&#34;,
                    Parameter.POSITIONAL_OR_KEYWORD,
                    annotation=forward_sig.parameters[
                        list(forward_sig.parameters)[0]
                    ].annotation,
                )
            ],
            return_annotation=float,
        )
        verify_sig = Signature(
            [
                Parameter(
                    &#34;synapse&#34;,
                    Parameter.POSITIONAL_OR_KEYWORD,
                    annotation=forward_sig.parameters[
                        list(forward_sig.parameters)[0]
                    ].annotation,
                )
            ],
            return_annotation=None,
        )

        # Check the signature of blacklist_fn, priority_fn and verify_fn if they are provided
        if blacklist_fn:
            assert (
                signature(blacklist_fn) == blacklist_sig
            ), &#34;The blacklist_fn function must have the signature: blacklist( synapse: {} ) -&gt; Tuple[bool, str]&#34;.format(
                request_name
            )
        if priority_fn:
            assert (
                signature(priority_fn) == priority_sig
            ), &#34;The priority_fn function must have the signature: priority( synapse: {} ) -&gt; float&#34;.format(
                request_name
            )
        if verify_fn:
            assert (
                signature(verify_fn) == verify_sig
            ), &#34;The verify_fn function must have the signature: verify( synapse: {} ) -&gt; None&#34;.format(
                request_name
            )

        # Store functions in appropriate attribute dictionaries
        self.forward_class_types[request_name] = forward_sig.parameters[
            list(forward_sig.parameters)[0]
        ].annotation
        self.blacklist_fns[request_name] = blacklist_fn
        self.priority_fns[request_name] = priority_fn
        self.verify_fns[request_name] = (
            verify_fn or self.default_verify
        )  # Use &#39;default_verify&#39; if &#39;verify_fn&#39; is None
        self.forward_fns[request_name] = forward_fn

        # Parse required hash fields from the forward function protocol defaults
        required_hash_fields = request_class.__dict__[&#34;__fields__&#34;][
            &#34;required_hash_fields&#34;
        ].default
        self.required_hash_fields[request_name] = required_hash_fields

        return self

    @classmethod
    def config(cls) -&gt; &#34;Config&#34;:
        &#34;&#34;&#34;
        Parses the command-line arguments to form a cybertensor configuration object.

        Returns:
            Config: Configuration object with settings from command-line arguments.
        &#34;&#34;&#34;
        parser = argparse.ArgumentParser()
        axon.add_args(parser)  # Add specific axon-related arguments
        return Config(parser, args=[])

    @classmethod
    def help(cls):
        &#34;&#34;&#34;
        Prints the help text (list of command-line arguments and their descriptions) to stdout.
        &#34;&#34;&#34;
        parser = argparse.ArgumentParser()
        axon.add_args(parser)  # Add specific axon-related arguments
        print(cls.__new__.__doc__)  # Print docstring of the class
        parser.print_help()  # Print parser&#39;s help text

    @classmethod
    def add_args(cls, parser: argparse.ArgumentParser, prefix: Optional[str] = None):
        &#34;&#34;&#34;
        Adds AxonServer-specific command-line arguments to the argument parser.

        Args:
            parser (argparse.ArgumentParser): Argument parser to which the arguments will be added.
            prefix (str, optional): Prefix to add to the argument names. Defaults to None.

        Note:
            Environment variables are used to define default values for the arguments.
        &#34;&#34;&#34;
        prefix_str = &#34;&#34; if prefix is None else prefix + &#34;.&#34;
        try:
            # Get default values from environment variables or use default values
            default_axon_port = os.getenv(&#34;BT_AXON_PORT&#34;) or 8091
            default_axon_ip = os.getenv(&#34;BT_AXON_IP&#34;) or &#34;[::]&#34;
            default_axon_external_port = os.getenv(&#34;BT_AXON_EXTERNAL_PORT&#34;) or None
            default_axon_external_ip = os.getenv(&#34;BT_AXON_EXTERNAL_IP&#34;) or None
            default_axon_max_workers = os.getenv(&#34;BT_AXON_MAX_WORERS&#34;) or 10

            # Add command-line arguments to the parser
            parser.add_argument(
                &#34;--&#34; + prefix_str + &#34;axon.port&#34;,
                type=int,
                help=&#34;The local port this axon endpoint is bound to. i.e. 8091&#34;,
                default=default_axon_port,
            )
            parser.add_argument(
                &#34;--&#34; + prefix_str + &#34;axon.ip&#34;,
                type=str,
                help=&#34;&#34;&#34;The local ip this axon binds to. ie. [::]&#34;&#34;&#34;,
                default=default_axon_ip,
            )
            parser.add_argument(
                &#34;--&#34; + prefix_str + &#34;axon.external_port&#34;,
                type=int,
                required=False,
                help=&#34;&#34;&#34;The public port this axon broadcasts to the network. i.e. 8091&#34;&#34;&#34;,
                default=default_axon_external_port,
            )
            parser.add_argument(
                &#34;--&#34; + prefix_str + &#34;axon.external_ip&#34;,
                type=str,
                required=False,
                help=&#34;&#34;&#34;The external ip this axon broadcasts to the network to. ie. [::]&#34;&#34;&#34;,
                default=default_axon_external_ip,
            )
            parser.add_argument(
                &#34;--&#34; + prefix_str + &#34;axon.max_workers&#34;,
                type=int,
                help=&#34;&#34;&#34;The maximum number connection handler threads working simultaneously on this endpoint. 
                        The grpc server distributes new worker threads to service requests up to this number.&#34;&#34;&#34;,
                default=default_axon_max_workers,
            )

        except argparse.ArgumentError:
            # Exception handling for re-parsing arguments
            pass

    async def verify_body_integrity(self, request: Request):
        &#34;&#34;&#34;
        The ``verify_body_integrity`` method in the cybertensor framework is a key security function within the
        Axon server&#39;s middleware. It is responsible for ensuring the integrity of the body of incoming HTTP
        requests.
        It asynchronously verifies the integrity of the body of a request by comparing the hash of required fields
        with the corresponding hashes provided in the request headers. This method is critical for ensuring
        that the incoming request payload has not been altered or tampered with during transmission, establishing
        a level of trust and security between the sender and receiver in the network.

        Args:
            request (Request): The incoming FastAPI request object containing both headers and the request body.

        Returns:
            dict: Returns the parsed body of the request as a dictionary if all the hash comparisons match,
                indicating that the body is intact and has not been tampered with.

        Raises:
            JSONResponse: Raises a JSONResponse with a 400 status code if any of the hash comparisons fail,
                        indicating a potential integrity issue with the incoming request payload.
                        The response includes the detailed error message specifying which field has a hash mismatch.

        This method performs several key functions:
        1. Decoding and loading the request body for inspection.
        2. Gathering required field names for hash comparison from the Axon configuration.
        3. Loading and parsing the request body into a dictionary.
        4. Reconstructing the Synapse object and recomputing the hash for verification and logging.
        5. Comparing the recomputed hash with the hash provided in the request headers for verification.
        Note:
            The integrity verification is an essential step in ensuring the security of the data exchange
            within the cybertensor network. It helps prevent tampering and manipulation of data during transit,
            thereby maintaining the reliability and trust in the network communication.
        &#34;&#34;&#34;
        # Await and load the request body, so we can inspect it
        body = await request.body()
        request_body = body.decode() if isinstance(body, bytes) else body

        # Gather the required field names from the axon&#39;s required_hash_fields dict
        request_name = request.url.path.split(&#34;/&#34;)[1]
        required_hash_fields = self.required_hash_fields[request_name]

        # Load the body dict and check if all required field hashes match
        body_dict = json.loads(request_body)

        # Reconstruct the synapse object from the body dict and recompute the hash
        syn = self.forward_class_types[request_name](**body_dict)  # type: ignore
        parsed_body_hash = syn.body_hash  # Rehash the body from request

        body_hash = request.headers.get(&#34;computed_body_hash&#34;, &#34;&#34;)
        if parsed_body_hash != body_hash:
            raise ValueError(
                f&#34;Hash mismatch between header body hash {body_hash} and parsed body hash {parsed_body_hash}&#34;
            )

        # If body is good, return the parsed body so that it can be passed onto the route function
        return body_dict

    @classmethod
    def check_config(cls, config: &#34;Config&#34;):
        &#34;&#34;&#34;
        This method checks the configuration for the axon&#39;s port and wallet.

        Args:
            config (Config): The config object holding axon settings.

        Raises:
            AssertionError: If the axon or external ports are not in range [1024, 65535]
        &#34;&#34;&#34;
        assert config.axon.port is None or (
                1024 &lt; config.axon.port &lt; 65535
        ), &#34;Axon port must be in range [1024, 65535]&#34;

        assert config.axon.external_port is None or (
                1024 &lt; config.axon.external_port &lt; 65535
        ), &#34;External port must be in range [1024, 65535]&#34;

    def to_string(self):
        &#34;&#34;&#34;
        Provides a human-readable representation of the AxonInfo for this Axon.
        &#34;&#34;&#34;
        return self.info().to_string()

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Provides a human-readable representation of the Axon instance.
        &#34;&#34;&#34;
        return &#34;Axon({}, {}, {}, {}, {})&#34;.format(
            self.ip,
            self.port,
            self.wallet.hotkey.address,
            &#34;started&#34; if self.started else &#34;stopped&#34;,
            list(self.forward_fns.keys()),
        )

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Provides a machine-readable (unambiguous) representation of the Axon instance.
        It is made identical to __str__ in this case.
        &#34;&#34;&#34;
        return self.__str__()

    def __del__(self):
        &#34;&#34;&#34;
        This magic method is called when the Axon object is about to be destroyed.
        It ensures that the Axon server shuts down properly.
        &#34;&#34;&#34;
        self.stop()

    def start(self) -&gt; &#34;cybertensor.axon&#34;:
        &#34;&#34;&#34;
        Starts the Axon server and its underlying FastAPI server thread, transitioning the state of the
        Axon instance to ``started``. This method initiates the server&#39;s ability to accept and process
        incoming network requests, making it an active participant in the cybertensor network.
        The start method triggers the FastAPI server associated with the Axon to begin listening for
        incoming requests. It is a crucial step in making the neuron represented by this Axon operational
        within the cybertensor network.
        Returns:
            cybertensor.axon: The Axon instance in the &#39;started&#39; state.
        Example::
            my_axon = cybertensor.axon(...)
            ... # setup axon, attach functions, etc.
            my_axon.start()  # Starts the axon server
        Note:
            After invoking this method, the Axon is ready to handle requests as per its configured endpoints and custom
            logic.
        &#34;&#34;&#34;
        self.fast_server.start()
        self.started = True
        return self

    def stop(self) -&gt; &#34;cybertensor.axon&#34;:
        &#34;&#34;&#34;
        Stops the Axon server and its underlying GRPC server thread, transitioning the state of the Axon
        instance to ``stopped``. This method ceases the server&#39;s ability to accept new network requests,
        effectively removing the neuron&#39;s server-side presence in the cybertensor network.
        By stopping the FastAPI server, the Axon ceases to listen for incoming requests, and any existing
        connections are gracefully terminated. This function is typically used when the neuron is being
        shut down or needs to temporarily go offline.
        Returns:
            cybertensor.axon: The Axon instance in the &#39;stopped&#39; state.
        Example::
            my_axon = cybertensor.axon(...)
            my_axon.start()
            ...
            my_axon.stop()  # Stops the axon server
        Note:
            It is advisable to ensure that all ongoing processes or requests are completed or properly handled before
            invoking this method.
        &#34;&#34;&#34;
        self.fast_server.stop()
        self.started = False
        return self

    def serve(
        self, netuid: int, cwtensor: Optional[cybertensor.cwtensor] = None
    ) -&gt; &#34;cybertensor.axon&#34;:
        &#34;&#34;&#34;
        Serves the Axon on the specified cwtensor connection using the configured wallet. This method
        registers the Axon with a specific subnet within the cybertensor network, identified by the ``netuid``.
        It links the Axon to the broader network, allowing it to participate in the decentralized exchange
        of information.
        Args:
            netuid (int): The unique identifier of the subnet to register on. This ID is essential for the Axon to
                correctly position itself within the cybertensor network topology.
            cwtensor (cybertensor.cwtensor, optional): The cwtensor connection to use for serving. If not provided,
                a new connection is established based on default configurations.
        Returns:
            cybertensor.axon: The Axon instance that is now actively serving on the specified cwtensor.
        Example::
            my_axon = cybertensor.axon(...)
            cwtensor = ct.cwtensor(network=&#34;local&#34;) # Local by default
            my_axon.serve(netuid=1, cwtensor=cwtensor)  # Serves the axon on subnet with netuid 1
        Note:
            The ``serve`` method is crucial for integrating the Axon into the cybertensor network, allowing it
            to start receiving and processing requests from other neurons.
        &#34;&#34;&#34;
        if cwtensor is None:
            cwtensor = cybertensor.cwtensor()
        cwtensor.serve_axon(netuid=netuid, axon=self)
        return self

    async def default_verify(self, synapse: cybertensor.Synapse):
        &#34;&#34;&#34;
        This method is used to verify the authenticity of a received message using a digital signature.
        It ensures that the message was not tampered with and was sent by the expected sender.
        The :func:`default_verify` method in the cybertensor framework is a critical security function within the
        Axon server. It is designed to authenticate incoming messages by verifying their digital
        signatures. This verification ensures the integrity of the message and confirms that it was
        indeed sent by the claimed sender. The method plays a pivotal role in maintaining the trustworthiness
        and reliability of the communication within the cybertensor network.
        Key Features
            Security Assurance
                The default_verify method is crucial for ensuring the security of the cybertensor network. By verifying
                digital signatures, it guards against unauthorized access and data manipulation.
            Preventing Replay Attacks
                The method checks for increasing nonce values, which is a vital
                step in preventing replay attacks. A replay attack involves an adversary reusing or
                delaying the transmission of a valid data transmission to deceive the receiver.
            Authenticity and Integrity Checks
                By verifying that the message&#39;s digital signature matches
                its content, the method ensures the message&#39;s authenticity (it comes from the claimed
                sender) and integrity (it hasn&#39;t been altered during transmission).
            Trust in Communication
                This method fosters trust in the network communication. Neurons
                (nodes in the cybertensor network) can confidently interact, knowing that the messages they
                receive are genuine and have not been tampered with.
            Cryptographic Techniques
                The method&#39;s reliance on asymmetric encryption techniques is a
                cornerstone of modern cryptographic security, ensuring that only entities with the correct
                cryptographic keys can participate in secure communication.

        Args:
            synapse: cybertensor.Synapse
                cybertensor request synapse.

        Raises:
            Exception: If the ``receiver_hotkey`` doesn&#39;t match with ``self.receiver_hotkey``.
            Exception: If the nonce is not larger than the previous nonce for the same endpoint key.
            Exception: If the signature verification fails.

        After successful verification, the nonce for the given endpoint key is updated.

        Note:
            The verification process assumes the use of an asymmetric encryption algorithm, where the sender signs the
            message with their private key and the receiver verifies the signature using the sender&#39;s public key.
        &#34;&#34;&#34;
        # Build the keypair from the dendrite_hotkey
        if synapse.dendrite is not None:
            cybertensor.logging.info(f&#34;dendrite: {synapse.dendrite}&#34;)
            # NOTE added public key to the synapese for correct keypair initialization
            # keypair = Keypair(address=synapse.dendrite.hotkey)
            keypair = Keypair(address=synapse.dendrite.hotkey, public_key=synapse.dendrite.pubkey)
            # Build the signature messages.
            message = (f&#34;{synapse.dendrite.nonce}.{synapse.dendrite.hotkey}.{self.wallet.hotkey.address}.&#34;
                       f&#34;{synapse.dendrite.uuid}.{synapse.computed_body_hash}&#34;)

            # Build the unique endpoint key.
            endpoint_key = f&#34;{synapse.dendrite.hotkey}:{synapse.dendrite.uuid}&#34;

            # Check the nonce from the endpoint key.
            if (
                    endpoint_key in self.nonces.keys()
                    and self.nonces[endpoint_key] is not None
                    and synapse.dendrite.nonce is not None
                    and synapse.dendrite.nonce &lt;= self.nonces[endpoint_key]
            ):
                raise Exception(&#34;Nonce is too small&#34;)

            if not keypair.verify(message, synapse.dendrite.signature):
                raise Exception(
                    f&#34;Signature mismatch with {message} and {synapse.dendrite.signature}&#34;
                )

            # Success
            self.nonces[endpoint_key] = synapse.dendrite.nonce  # type: ignore
        else:
            raise SynapseDendriteNoneException()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="cybertensor.axon.axon.add_args"><code class="name flex">
<span>def <span class="ident">add_args</span></span>(<span>parser: argparse.ArgumentParser, prefix: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds AxonServer-specific command-line arguments to the argument parser.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parser</code></strong> :&ensp;<code>argparse.ArgumentParser</code></dt>
<dd>Argument parser to which the arguments will be added.</dd>
<dt><strong><code>prefix</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Prefix to add to the argument names. Defaults to None.</dd>
</dl>
<h2 id="note">Note</h2>
<p>Environment variables are used to define default values for the arguments.</p></div>
</dd>
<dt id="cybertensor.axon.axon.check_config"><code class="name flex">
<span>def <span class="ident">check_config</span></span>(<span>config: Config)</span>
</code></dt>
<dd>
<div class="desc"><p>This method checks the configuration for the axon's port and wallet.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>Config</code></dt>
<dd>The config object holding axon settings.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AssertionError</code></dt>
<dd>If the axon or external ports are not in range [1024, 65535]</dd>
</dl></div>
</dd>
<dt id="cybertensor.axon.axon.config"><code class="name flex">
<span>def <span class="ident">config</span></span>(<span>) ‑> <a title="cybertensor.config.Config" href="config.html#cybertensor.config.Config">Config</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parses the command-line arguments to form a cybertensor configuration object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Config</code></dt>
<dd>Configuration object with settings from command-line arguments.</dd>
</dl></div>
</dd>
<dt id="cybertensor.axon.axon.help"><code class="name flex">
<span>def <span class="ident">help</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the help text (list of command-line arguments and their descriptions) to stdout.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="cybertensor.axon.axon.attach"><code class="name flex">
<span>def <span class="ident">attach</span></span>(<span>self, forward_fn: Callable, blacklist_fn: Optional[Callable] = None, priority_fn: Optional[Callable] = None, verify_fn: Optional[Callable] = None) ‑> <a title="cybertensor.axon.axon" href="#cybertensor.axon.axon">axon</a></span>
</code></dt>
<dd>
<div class="desc"><p>Attaches custom functions to the Axon server for handling incoming requests. This method enables
the Axon to define specific behaviors for request forwarding, verification, blacklisting, and
prioritization, thereby customizing its interaction within the cybertensor network.
Registers an API endpoint to the FastAPI application router.
It uses the name of the first argument of the :func:<code>forward_fn</code> function as the endpoint name.
The attach method in the cybertensor framework's axon class is a crucial function for registering
API endpoints to the Axon's FastAPI application router. This method allows the Axon server to
define how it handles incoming requests by attaching functions for forwarding, verifying,
blacklisting, and prioritizing requests. It's a key part of customizing the server's behavior
and ensuring efficient and secure handling of requests within the cybertensor network.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>forward_fn</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Function to be called when the API endpoint is accessed. It should have at least one
argument.</dd>
<dt><strong><code>blacklist_fn</code></strong> :&ensp;<code>Callable</code>, optional</dt>
<dd>Function to filter out undesired requests. It should take the same
arguments as :func:<code>forward_fn</code> and return a boolean value. Defaults to <code>None</code>, meaning no blacklist
filter will be used.</dd>
<dt><strong><code>priority_fn</code></strong> :&ensp;<code>Callable</code>, optional</dt>
<dd>Function to rank requests based on their priority. It should take the same
arguments as :func:<code>forward_fn</code> and return a numerical value representing the request's priority.
Defaults to <code>None</code>, meaning no priority sorting will be applied.</dd>
<dt><strong><code>verify_fn</code></strong> :&ensp;<code>Callable</code>, optional</dt>
<dd>Function to verify requests. It should take the same arguments as
:func:<code>forward_fn</code> and return a boolean value. If <code>None</code>, :func:<code>self.default_verify</code> function will be used.</dd>
</dl>
<h2 id="note">Note</h2>
<p>The methods :func:<code>forward_fn</code>, :func:<code>blacklist_fn</code>, :func:<code>priority_fn</code>, and :func:<code>verify_fn</code> should be
designed to receive the same parameters.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AssertionError</code></dt>
<dd>If :func:<code>forward_fn</code> does not have the signature: <code>forward( synapse: YourSynapse ) -&gt; synapse</code>.</dd>
<dt><code>AssertionError</code></dt>
<dd>If :func:<code>blacklist_fn</code> does not have the signature: <code>blacklist( synapse: YourSynapse ) -&gt; bool</code>.</dd>
<dt><code>AssertionError</code></dt>
<dd>If :func:<code>priority_fn</code> does not have the signature: <code>priority( synapse: YourSynapse ) -&gt; float</code>.</dd>
<dt><code>AssertionError</code></dt>
<dd>If :func:<code>verify_fn</code> does not have the signature: <code>verify( synapse: YourSynapse ) -&gt; None</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>self</code></dt>
<dd>Returns the instance of the AxonServer class for potential method chaining.</dd>
</dl>
<p>Example Usage::
def forward_custom(synapse: MyCustomSynapse) -&gt; MyCustomSynapse:
# Custom logic for processing the request
return synapse
def blacklist_custom(synapse: MyCustomSynapse) -&gt; Tuple[bool, str]:
return True, "Allowed!"
def priority_custom(synapse: MyCustomSynapse) -&gt; float:
return 1.0
def verify_custom(synapse: MyCustomSynapse):
# Custom logic for verifying the request
pass
my_axon = cybertensor.axon(&hellip;)
my_axon.attach(forward_fn=forward_custom, verify_fn=verify_custom)</p>
<h2 id="note_1">Note</h2>
<p>The :func:<code>attach</code> method is fundamental in setting up the Axon server's request handling capabilities,
enabling it to participate effectively and securely in the cybertensor network. The flexibility
offered by this method allows developers to tailor the Axon's behavior to specific requirements and
use cases.</p></div>
</dd>
<dt id="cybertensor.axon.axon.default_verify"><code class="name flex">
<span>async def <span class="ident">default_verify</span></span>(<span>self, synapse: <a title="cybertensor.synapse.Synapse" href="synapse.html#cybertensor.synapse.Synapse">Synapse</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is used to verify the authenticity of a received message using a digital signature.
It ensures that the message was not tampered with and was sent by the expected sender.
The :func:<code>default_verify</code> method in the cybertensor framework is a critical security function within the
Axon server. It is designed to authenticate incoming messages by verifying their digital
signatures. This verification ensures the integrity of the message and confirms that it was
indeed sent by the claimed sender. The method plays a pivotal role in maintaining the trustworthiness
and reliability of the communication within the cybertensor network.
Key Features
Security Assurance
The default_verify method is crucial for ensuring the security of the cybertensor network. By verifying
digital signatures, it guards against unauthorized access and data manipulation.
Preventing Replay Attacks
The method checks for increasing nonce values, which is a vital
step in preventing replay attacks. A replay attack involves an adversary reusing or
delaying the transmission of a valid data transmission to deceive the receiver.
Authenticity and Integrity Checks
By verifying that the message's digital signature matches
its content, the method ensures the message's authenticity (it comes from the claimed
sender) and integrity (it hasn't been altered during transmission).
Trust in Communication
This method fosters trust in the network communication. Neurons
(nodes in the cybertensor network) can confidently interact, knowing that the messages they
receive are genuine and have not been tampered with.
Cryptographic Techniques
The method's reliance on asymmetric encryption techniques is a
cornerstone of modern cryptographic security, ensuring that only entities with the correct
cryptographic keys can participate in secure communication.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>synapse</code></strong></dt>
<dd>cybertensor.Synapse
cybertensor request synapse.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>If the <code>receiver_hotkey</code> doesn't match with <code>self.receiver_hotkey</code>.</dd>
<dt><code>Exception</code></dt>
<dd>If the nonce is not larger than the previous nonce for the same endpoint key.</dd>
<dt><code>Exception</code></dt>
<dd>If the signature verification fails.</dd>
</dl>
<p>After successful verification, the nonce for the given endpoint key is updated.</p>
<h2 id="note">Note</h2>
<p>The verification process assumes the use of an asymmetric encryption algorithm, where the sender signs the
message with their private key and the receiver verifies the signature using the sender's public key.</p></div>
</dd>
<dt id="cybertensor.axon.axon.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> <a title="cybertensor.chain_data.AxonInfo" href="chain_data.html#cybertensor.chain_data.AxonInfo">AxonInfo</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the axon info object associated with this axon.</p></div>
</dd>
<dt id="cybertensor.axon.axon.serve"><code class="name flex">
<span>def <span class="ident">serve</span></span>(<span>self, netuid: int, cwtensor: Optional[<a title="cybertensor.cwtensor.cwtensor" href="cwtensor.html#cybertensor.cwtensor.cwtensor">cwtensor</a>] = None) ‑> <a title="cybertensor.axon.axon" href="#cybertensor.axon.axon">axon</a></span>
</code></dt>
<dd>
<div class="desc"><p>Serves the Axon on the specified cwtensor connection using the configured wallet. This method
registers the Axon with a specific subnet within the cybertensor network, identified by the <code>netuid</code>.
It links the Axon to the broader network, allowing it to participate in the decentralized exchange
of information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>netuid</code></strong> :&ensp;<code>int</code></dt>
<dd>The unique identifier of the subnet to register on. This ID is essential for the Axon to
correctly position itself within the cybertensor network topology.</dd>
<dt><strong><code>cwtensor</code></strong> :&ensp;<code><a title="cybertensor.cwtensor" href="cwtensor.html">cybertensor.cwtensor</a></code>, optional</dt>
<dd>The cwtensor connection to use for serving. If not provided,
a new connection is established based on default configurations.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="cybertensor.axon" href="#cybertensor.axon">cybertensor.axon</a></code></dt>
<dd>The Axon instance that is now actively serving on the specified cwtensor.</dd>
</dl>
<p>Example::
my_axon = cybertensor.axon(&hellip;)
cwtensor = ct.cwtensor(network="local") # Local by default
my_axon.serve(netuid=1, cwtensor=cwtensor)
# Serves the axon on subnet with netuid 1</p>
<h2 id="note">Note</h2>
<p>The <code>serve</code> method is crucial for integrating the Axon into the cybertensor network, allowing it
to start receiving and processing requests from other neurons.</p></div>
</dd>
<dt id="cybertensor.axon.axon.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self) ‑> <a title="cybertensor.axon.axon" href="#cybertensor.axon.axon">axon</a></span>
</code></dt>
<dd>
<div class="desc"><p>Starts the Axon server and its underlying FastAPI server thread, transitioning the state of the
Axon instance to <code>started</code>. This method initiates the server's ability to accept and process
incoming network requests, making it an active participant in the cybertensor network.
The start method triggers the FastAPI server associated with the Axon to begin listening for
incoming requests. It is a crucial step in making the neuron represented by this Axon operational
within the cybertensor network.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="cybertensor.axon" href="#cybertensor.axon">cybertensor.axon</a></code></dt>
<dd>The Axon instance in the 'started' state.</dd>
</dl>
<p>Example::
my_axon = cybertensor.axon(&hellip;)
&hellip; # setup axon, attach functions, etc.
my_axon.start()
# Starts the axon server</p>
<h2 id="note">Note</h2>
<p>After invoking this method, the Axon is ready to handle requests as per its configured endpoints and custom
logic.</p></div>
</dd>
<dt id="cybertensor.axon.axon.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self) ‑> <a title="cybertensor.axon.axon" href="#cybertensor.axon.axon">axon</a></span>
</code></dt>
<dd>
<div class="desc"><p>Stops the Axon server and its underlying GRPC server thread, transitioning the state of the Axon
instance to <code>stopped</code>. This method ceases the server's ability to accept new network requests,
effectively removing the neuron's server-side presence in the cybertensor network.
By stopping the FastAPI server, the Axon ceases to listen for incoming requests, and any existing
connections are gracefully terminated. This function is typically used when the neuron is being
shut down or needs to temporarily go offline.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="cybertensor.axon" href="#cybertensor.axon">cybertensor.axon</a></code></dt>
<dd>The Axon instance in the 'stopped' state.</dd>
</dl>
<p>Example::
my_axon = cybertensor.axon(&hellip;)
my_axon.start()
&hellip;
my_axon.stop()
# Stops the axon server</p>
<h2 id="note">Note</h2>
<p>It is advisable to ensure that all ongoing processes or requests are completed or properly handled before
invoking this method.</p></div>
</dd>
<dt id="cybertensor.axon.axon.to_string"><code class="name flex">
<span>def <span class="ident">to_string</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides a human-readable representation of the AxonInfo for this Axon.</p></div>
</dd>
<dt id="cybertensor.axon.axon.verify_body_integrity"><code class="name flex">
<span>async def <span class="ident">verify_body_integrity</span></span>(<span>self, request: starlette.requests.Request)</span>
</code></dt>
<dd>
<div class="desc"><p>The <code>verify_body_integrity</code> method in the cybertensor framework is a key security function within the
Axon server's middleware. It is responsible for ensuring the integrity of the body of incoming HTTP
requests.
It asynchronously verifies the integrity of the body of a request by comparing the hash of required fields
with the corresponding hashes provided in the request headers. This method is critical for ensuring
that the incoming request payload has not been altered or tampered with during transmission, establishing
a level of trust and security between the sender and receiver in the network.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>Request</code></dt>
<dd>The incoming FastAPI request object containing both headers and the request body.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Returns the parsed body of the request as a dictionary if all the hash comparisons match,
indicating that the body is intact and has not been tampered with.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>JSONResponse</code></dt>
<dd>Raises a JSONResponse with a 400 status code if any of the hash comparisons fail,
indicating a potential integrity issue with the incoming request payload.
The response includes the detailed error message specifying which field has a hash mismatch.</dd>
</dl>
<p>This method performs several key functions:
1. Decoding and loading the request body for inspection.
2. Gathering required field names for hash comparison from the Axon configuration.
3. Loading and parsing the request body into a dictionary.
4. Reconstructing the Synapse object and recomputing the hash for verification and logging.
5. Comparing the recomputed hash with the hash provided in the request headers for verification.</p>
<h2 id="note">Note</h2>
<p>The integrity verification is an essential step in ensuring the security of the data exchange
within the cybertensor network. It helps prevent tampering and manipulation of data during transit,
thereby maintaining the reliability and trust in the network communication.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cybertensor" href="index.html">cybertensor</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="cybertensor.axon.create_error_response" href="#cybertensor.axon.create_error_response">create_error_response</a></code></li>
<li><code><a title="cybertensor.axon.log_and_handle_error" href="#cybertensor.axon.log_and_handle_error">log_and_handle_error</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cybertensor.axon.AxonMiddleware" href="#cybertensor.axon.AxonMiddleware">AxonMiddleware</a></code></h4>
<ul class="two-column">
<li><code><a title="cybertensor.axon.AxonMiddleware.blacklist" href="#cybertensor.axon.AxonMiddleware.blacklist">blacklist</a></code></li>
<li><code><a title="cybertensor.axon.AxonMiddleware.dispatch" href="#cybertensor.axon.AxonMiddleware.dispatch">dispatch</a></code></li>
<li><code><a title="cybertensor.axon.AxonMiddleware.postprocess" href="#cybertensor.axon.AxonMiddleware.postprocess">postprocess</a></code></li>
<li><code><a title="cybertensor.axon.AxonMiddleware.preprocess" href="#cybertensor.axon.AxonMiddleware.preprocess">preprocess</a></code></li>
<li><code><a title="cybertensor.axon.AxonMiddleware.priority" href="#cybertensor.axon.AxonMiddleware.priority">priority</a></code></li>
<li><code><a title="cybertensor.axon.AxonMiddleware.run" href="#cybertensor.axon.AxonMiddleware.run">run</a></code></li>
<li><code><a title="cybertensor.axon.AxonMiddleware.verify" href="#cybertensor.axon.AxonMiddleware.verify">verify</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cybertensor.axon.FastAPIThreadedServer" href="#cybertensor.axon.FastAPIThreadedServer">FastAPIThreadedServer</a></code></h4>
<ul class="">
<li><code><a title="cybertensor.axon.FastAPIThreadedServer.install_signal_handlers" href="#cybertensor.axon.FastAPIThreadedServer.install_signal_handlers">install_signal_handlers</a></code></li>
<li><code><a title="cybertensor.axon.FastAPIThreadedServer.is_running" href="#cybertensor.axon.FastAPIThreadedServer.is_running">is_running</a></code></li>
<li><code><a title="cybertensor.axon.FastAPIThreadedServer.run_in_thread" href="#cybertensor.axon.FastAPIThreadedServer.run_in_thread">run_in_thread</a></code></li>
<li><code><a title="cybertensor.axon.FastAPIThreadedServer.should_exit" href="#cybertensor.axon.FastAPIThreadedServer.should_exit">should_exit</a></code></li>
<li><code><a title="cybertensor.axon.FastAPIThreadedServer.start" href="#cybertensor.axon.FastAPIThreadedServer.start">start</a></code></li>
<li><code><a title="cybertensor.axon.FastAPIThreadedServer.stop" href="#cybertensor.axon.FastAPIThreadedServer.stop">stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cybertensor.axon.axon" href="#cybertensor.axon.axon">axon</a></code></h4>
<ul class="">
<li><code><a title="cybertensor.axon.axon.add_args" href="#cybertensor.axon.axon.add_args">add_args</a></code></li>
<li><code><a title="cybertensor.axon.axon.attach" href="#cybertensor.axon.axon.attach">attach</a></code></li>
<li><code><a title="cybertensor.axon.axon.check_config" href="#cybertensor.axon.axon.check_config">check_config</a></code></li>
<li><code><a title="cybertensor.axon.axon.config" href="#cybertensor.axon.axon.config">config</a></code></li>
<li><code><a title="cybertensor.axon.axon.default_verify" href="#cybertensor.axon.axon.default_verify">default_verify</a></code></li>
<li><code><a title="cybertensor.axon.axon.help" href="#cybertensor.axon.axon.help">help</a></code></li>
<li><code><a title="cybertensor.axon.axon.info" href="#cybertensor.axon.axon.info">info</a></code></li>
<li><code><a title="cybertensor.axon.axon.serve" href="#cybertensor.axon.axon.serve">serve</a></code></li>
<li><code><a title="cybertensor.axon.axon.start" href="#cybertensor.axon.axon.start">start</a></code></li>
<li><code><a title="cybertensor.axon.axon.stop" href="#cybertensor.axon.axon.stop">stop</a></code></li>
<li><code><a title="cybertensor.axon.axon.to_string" href="#cybertensor.axon.axon.to_string">to_string</a></code></li>
<li><code><a title="cybertensor.axon.axon.verify_body_integrity" href="#cybertensor.axon.axon.verify_body_integrity">verify_body_integrity</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
