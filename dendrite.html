<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>cybertensor.dendrite API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cybertensor.dendrite</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cybertensor.dendrite.dendrite"><code class="flex name class">
<span>class <span class="ident">dendrite</span></span>
<span>(</span><span>wallet: Optional[Union[Wallet, cybertensor.Keypair]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>The Dendrite class, inheriting from PyTorch's Module class, represents the abstracted
implementation of a network client module. In the brain analogy, dendrites receive signals
from other neurons (in this case, network servers or axons), and the Dendrite class here is designed
to send requests to those endpoint to recieve inputs.</p>
<p>This class includes a wallet or keypair used for signing messages, and methods for making
HTTP requests to the network servers. It also provides functionalities such as logging
network requests and processing server responses.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>keypair</code></strong></dt>
<dd>The wallet or keypair used for signing messages.</dd>
<dt><strong><code>external_ip</code></strong> :&ensp;<code>str</code></dt>
<dd>The external IP address of the local system.</dd>
<dt><strong><code>synapse_history</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of Synapse objects representing the historical responses.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p><strong>str</strong>(): Returns a string representation of the Dendrite object.
<strong>repr</strong>(): Returns a string representation of the Dendrite object, acting as a fallback for <strong>str</strong>().
query(self, <em>args, </em>*kwargs) -&gt; Union[cybertensor.Synapse, List[cybertensor.Synapse]]:
Makes synchronous requests to one or multiple target Axons and returns responses.</p>
<p>forward(self, axons, synapse=cybertensor.Synapse(), timeout=12, deserialize=True, run_async=True, streaming=False) -&gt; cybertensor.Synapse:
Asynchronously sends requests to one or multiple Axons and collates their responses.</p>
<p>call(self, target_axon, synapse=cybertensor.Synapse(), timeout=12.0, deserialize=True) -&gt; cybertensor.Synapse:
Asynchronously sends a request to a specified Axon and processes the response.</p>
<p>call_stream(self, target_axon, synapse=cybertensor.Synapse(), timeout=12.0, deserialize=True) -&gt; AsyncGenerator[cybertensor.Synapse, None]:
Sends a request to a specified Axon and yields an AsyncGenerator that contains streaming
response chunks before finally yielding the filled Synapse as the final element.</p>
<p>preprocess_synapse_for_request(self, target_axon_info, synapse, timeout=12.0) -&gt; cybertensor.Synapse:
Preprocesses the synapse for making a request, including building headers and signing.</p>
<p>process_server_response(self, server_response, json_response, local_synapse):
Processes the server response, updates the local synapse state, and merges headers.</p>
<p>close_session(self):
Synchronously closes the internal aiohttp client session.</p>
<p>aclose_session(self):
Asynchronously closes the internal aiohttp client session.</p>
<h2 id="note">Note</h2>
<p>When working with async <code>aiohttp &lt;https://github.com/aio-libs/aiohttp&gt;</code>_ client sessions, it is recommended to
use a context manager.</p>
<p>Example with a context manager:
&gt;&gt;&gt; aysnc with dendrite(wallet = Wallet()) as d:
&gt;&gt;&gt;
print(d)
&gt;&gt;&gt;
d( <axon> ) # ping axon
&gt;&gt;&gt;
d( [<axons>] ) # ping multiple
&gt;&gt;&gt;
d( cybertensor.axon(), cybertensor.Synapse )</p>
<p>However, you are able to safely call dendrite.query() without a context manager in a synchronous setting.</p>
<p>Example without a context manager:
&gt;&gt;&gt; d = dendrite(wallet = Wallet() )
&gt;&gt;&gt; print(d)
&gt;&gt;&gt; d( <axon> ) # ping axon
&gt;&gt;&gt; d( [<axons>] ) # ping multiple
&gt;&gt;&gt; d( cybertensor.axon(), cybertensor.Synapse )</p>
<p>Initializes the Dendrite object, setting up essential properties.</p>
<h2 id="args_1">Args</h2>
<p>wallet (Optional[Union['Wallet', 'cybertensor.Keypair']], optional):
The user's wallet or keypair used for signing messages. Defaults to None,
in which case a new Wallet().hotkey is generated and used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class dendrite(torch.nn.Module):
    &#34;&#34;&#34;
    The Dendrite class, inheriting from PyTorch&#39;s Module class, represents the abstracted
    implementation of a network client module. In the brain analogy, dendrites receive signals
    from other neurons (in this case, network servers or axons), and the Dendrite class here is designed
    to send requests to those endpoint to recieve inputs.

    This class includes a wallet or keypair used for signing messages, and methods for making
    HTTP requests to the network servers. It also provides functionalities such as logging
    network requests and processing server responses.

    Args:
        keypair: The wallet or keypair used for signing messages.
        external_ip (str): The external IP address of the local system.
        synapse_history (list): A list of Synapse objects representing the historical responses.

    Methods:
        __str__(): Returns a string representation of the Dendrite object.
        __repr__(): Returns a string representation of the Dendrite object, acting as a fallback for __str__().
        query(self, *args, **kwargs) -&gt; Union[cybertensor.Synapse, List[cybertensor.Synapse]]:
            Makes synchronous requests to one or multiple target Axons and returns responses.

        forward(self, axons, synapse=cybertensor.Synapse(), timeout=12, deserialize=True, run_async=True, streaming=False) -&gt; cybertensor.Synapse:
            Asynchronously sends requests to one or multiple Axons and collates their responses.

        call(self, target_axon, synapse=cybertensor.Synapse(), timeout=12.0, deserialize=True) -&gt; cybertensor.Synapse:
            Asynchronously sends a request to a specified Axon and processes the response.

        call_stream(self, target_axon, synapse=cybertensor.Synapse(), timeout=12.0, deserialize=True) -&gt; AsyncGenerator[cybertensor.Synapse, None]:
            Sends a request to a specified Axon and yields an AsyncGenerator that contains streaming
            response chunks before finally yielding the filled Synapse as the final element.

        preprocess_synapse_for_request(self, target_axon_info, synapse, timeout=12.0) -&gt; cybertensor.Synapse:
            Preprocesses the synapse for making a request, including building headers and signing.

        process_server_response(self, server_response, json_response, local_synapse):
            Processes the server response, updates the local synapse state, and merges headers.

        close_session(self):
            Synchronously closes the internal aiohttp client session.

        aclose_session(self):
            Asynchronously closes the internal aiohttp client session.

    NOTE:
        When working with async `aiohttp &lt;https://github.com/aio-libs/aiohttp&gt;`_ client sessions, it is recommended to
        use a context manager.

    Example with a context manager:
        &gt;&gt;&gt; aysnc with dendrite(wallet = Wallet()) as d:
        &gt;&gt;&gt;     print(d)
        &gt;&gt;&gt;     d( &lt;axon&gt; ) # ping axon
        &gt;&gt;&gt;     d( [&lt;axons&gt;] ) # ping multiple
        &gt;&gt;&gt;     d( cybertensor.axon(), cybertensor.Synapse )

    However, you are able to safely call dendrite.query() without a context manager in a synchronous setting.

    Example without a context manager:
        &gt;&gt;&gt; d = dendrite(wallet = Wallet() )
        &gt;&gt;&gt; print(d)
        &gt;&gt;&gt; d( &lt;axon&gt; ) # ping axon
        &gt;&gt;&gt; d( [&lt;axons&gt;] ) # ping multiple
        &gt;&gt;&gt; d( cybertensor.axon(), cybertensor.Synapse )
    &#34;&#34;&#34;

    def __init__(
        self, wallet: Optional[Union[Wallet, cybertensor.Keypair]] = None
    ):
        &#34;&#34;&#34;
        Initializes the Dendrite object, setting up essential properties.

        Args:
            wallet (Optional[Union[&#39;Wallet&#39;, &#39;cybertensor.Keypair&#39;]], optional):
                The user&#39;s wallet or keypair used for signing messages. Defaults to None,
                in which case a new Wallet().hotkey is generated and used.
        &#34;&#34;&#34;
        # Initialize the parent class
        super(dendrite, self).__init__()

        # Unique identifier for the instance
        self.uuid = str(uuid.uuid1())

        # Get the external IP
        self.external_ip = cybertensor.utils.networking.get_external_ip()

        # If a wallet or keypair is provided, use its hotkey. If not, generate a new one.
        self.keypair = (
            wallet.hotkey if isinstance(wallet, Wallet) else wallet
        ) or Wallet().hotkey

        self.synapse_history: list = []

        self._session: Optional[aiohttp.ClientSession] = None

    @property
    async def session(self) -&gt; aiohttp.ClientSession:
        &#34;&#34;&#34;
        An asynchronous property that provides access to the internal `aiohttp &lt;https://github.com/aio-libs/aiohttp&gt;`_ client session.
        This property ensures the management of HTTP connections in an efficient way. It lazily
        initializes the `aiohttp.ClientSession &lt;https://docs.aiohttp.org/en/stable/client_reference.html#aiohttp.ClientSession&gt;`_
        on its first use. The session is then reused for subsequent HTTP requests, offering performance benefits by
        reusing underlying connections.
        This is used internally by the dendrite when querying axons, and should not be used directly
        unless absolutely necessary for your application.
        Returns:
            aiohttp.ClientSession: The active `aiohttp &lt;https://github.com/aio-libs/aiohttp&gt;`_ client session instance.
            If no session exists, a new one is created and returned. This session is used for asynchronous HTTP requests
            within the dendrite, adhering to the async nature of the network interactions in the cybertensor framework.
        Example usage::
            import cybertensor as ct                    # Import cybertensor
            wallet = ct.Wallet( ... )                 # Initialize a wallet
            dendrite = ct.dendrite( wallet )          # Initialize a dendrite instance with the wallet
            async with (await dendrite.session).post( # Use the session to make an HTTP POST request
                url,                                  # URL to send the request to
                headers={...},                        # Headers dict to be sent with the request
                json={...},                           # JSON body data to be sent with the request
                timeout=10,                           # Timeout duration in seconds
            ) as response:
                json_response = await response.json() # Extract the JSON response from the server
        &#34;&#34;&#34;
        if self._session is None:
            self._session = aiohttp.ClientSession()
        return self._session

    def close_session(self):
        &#34;&#34;&#34;
        Closes the internal `aiohttp &lt;https://github.com/aio-libs/aiohttp&gt;`_ client session synchronously.
        This method ensures the proper closure and cleanup of the aiohttp client session, releasing any
        resources like open connections and internal buffers. It is crucial for preventing resource leakage
        and should be called when the dendrite instance is no longer in use, especially in synchronous contexts.
        Note:
            This method utilizes asyncio&#39;s event loop to close the session asynchronously from a synchronous context.
            It is advisable to use this method only when asynchronous context management is not feasible.
        Usage:
            When finished with dendrite in a synchronous context
            :func:`dendrite_instance.close_session()`.
        &#34;&#34;&#34;
        if self._session:
            loop = asyncio.get_event_loop()
            loop.run_until_complete(self._session.close())
            self._session = None

    async def aclose_session(self):
        &#34;&#34;&#34;
        Asynchronously closes the internal `aiohttp &lt;https://github.com/aio-libs/aiohttp&gt;`_ client session.
        This method is the asynchronous counterpart to the :func:`close_session` method. It should be used in
        asynchronous contexts to ensure that the aiohttp client session is closed properly. The method
        releases resources associated with the session, such as open connections and internal buffers,
        which is essential for resource management in asynchronous applications.
        Usage:
            When finished with dendrite in an asynchronous context
            await :func:`dendrite_instance.aclose_session()`.
        Example::
            async with dendrite_instance:
                # Operations using dendrite
                pass
            # The session will be closed automatically after the above block
        &#34;&#34;&#34;
        if self._session:
            await self._session.close()
            self._session = None

    def _get_endpoint_url(self, target_axon, request_name):
        &#34;&#34;&#34;
        Constructs the endpoint URL for a network request to a target axon.
        This internal method generates the full HTTP URL for sending a request to the specified axon.
        The URL includes the IP address and port of the target axon, along with the specific request name.
        It differentiates between requests to the local system (using &#39;0.0.0.0&#39;) and external systems.
        Args:
            target_axon: The target axon object containing IP and port information.
            request_name: The specific name of the request being made.
        Returns:
            str: A string representing the complete HTTP URL for the request.
        &#34;&#34;&#34;
        endpoint = (
            f&#34;0.0.0.0:{str(target_axon.port)}&#34;
            if target_axon.ip == str(self.external_ip)
            else f&#34;{target_axon.ip}:{str(target_axon.port)}&#34;
        )
        return f&#34;http://{endpoint}/{request_name}&#34;

    def _handle_request_errors(self, synapse, request_name, exception):
        &#34;&#34;&#34;
        Handles exceptions that occur during network requests, updating the synapse with appropriate status codes and messages.
        This method interprets different types of exceptions and sets the corresponding status code and
        message in the synapse object. It covers common network errors such as connection issues and timeouts.
        Args:
            synapse: The synapse object associated with the request.
            request_name: The name of the request during which the exception occurred.
            exception: The exception object caught during the request.
        Note:
            This method updates the synapse object in-place.
        &#34;&#34;&#34;
        if isinstance(exception, aiohttp.ClientConnectorError):
            synapse.dendrite.status_code = &#34;503&#34;
            synapse.dendrite.status_message = f&#34;Service at {synapse.axon.ip}:{str(synapse.axon.port)}/{request_name} unavailable.&#34;
        elif isinstance(exception, asyncio.TimeoutError):
            synapse.dendrite.status_code = &#34;408&#34;
            synapse.dendrite.status_message = (
                f&#34;Timedout after {synapse.timeout} seconds.&#34;
            )
        else:
            synapse.dendrite.status_code = &#34;422&#34;
            synapse.dendrite.status_message = (
                f&#34;Failed to parse response object with error: {str(exception)}&#34;
            )

    def _log_outgoing_request(self, synapse):
        &#34;&#34;&#34;
        Logs information about outgoing requests for debugging purposes.
        This internal method logs key details about each outgoing request, including the size of the
        request, the name of the synapse, the axon&#39;s details, and a success indicator. This information
        is crucial for monitoring and debugging network activity within the cybertensor network.
        To turn on debug messages, set the environment variable CYBERTENSOR_DEBUG to ``1``, or call the cybertensor
        debug method like so::
            import cybertensor
            cybertensor.debug()
        Args:
            synapse: The synapse object representing the request being sent.
        &#34;&#34;&#34;
        cybertensor.logging.debug(
            f&#34;dendrite | --&gt; | {synapse.get_total_size()} B | {synapse.name} | {synapse.axon.hotkey} | {synapse.axon.ip}:{str(synapse.axon.port)} | 0 | Success&#34;
        )

    def _log_incoming_response(self, synapse):
        &#34;&#34;&#34;
        Logs information about incoming responses for debugging and monitoring.
        Similar to :func:`_log_outgoing_request`, this method logs essential details of the incoming responses,
        including the size of the response, synapse name, axon details, status code, and status message.
        This logging is vital for troubleshooting and understanding the network interactions in cybertensor.
        Args:
            synapse: The synapse object representing the received response.
        &#34;&#34;&#34;
        cybertensor.logging.debug(
            f&#34;dendrite | &lt;-- | {synapse.get_total_size()} B | {synapse.name} | {synapse.axon.hotkey} | {synapse.axon.ip}:{str(synapse.axon.port)} | {synapse.dendrite.status_code} | {synapse.dendrite.status_message}&#34;
        )

    def query(
            self, *args, **kwargs
    ) -&gt; List[Union[AsyncGenerator[Any, Any], cybertensor.Synapse, cybertensor.StreamingSynapse]]:
        &#34;&#34;&#34;
        Makes a synchronous request to multiple target Axons and returns the server responses.

        Cleanup is automatically handled and sessions are closed upon completed requests.

        Args:
          axons (Union[List[Union[&#39;cybertensor.AxonInfo&#39;, &#39;cybertensor.axon&#39;]], Union[&#39;cybertensor.AxonInfo&#39;, &#39;cybertensor.axon&#39;]]):
              The list of target Axon information.
          synapse (cybertensor.Synapse, optional): The Synapse object. Defaults to cybertensor.Synapse().
          timeout (float, optional): The request timeout duration in seconds.
              Defaults to 12.0 seconds.
        Returns:
          Union[cybertensor.Synapse, List[cybertensor.Synapse]]: If a single target axon is provided, returns the response
              from that axon. If multiple target axons are provided, returns a list of responses from all target axons.
        &#34;&#34;&#34;
        result = None
        try:
            loop = asyncio.get_event_loop()
            result = loop.run_until_complete(self.forward(*args, **kwargs))
        except:
            new_loop = asyncio.new_event_loop()
            asyncio.set_event_loop(new_loop)
            result = loop.run_until_complete(self.forward(*args, **kwargs))
            new_loop.close()
        finally:
            self.close_session()
            return result  # type: ignore

    async def forward(
        self,
        axons: Union[
            List[Union[cybertensor.AxonInfo, cybertensor.axon]],
            Union[cybertensor.AxonInfo, cybertensor.axon],
        ],
        synapse: cybertensor.Synapse = cybertensor.Synapse(),
        timeout: float = 12,
        deserialize: bool = True,
        run_async: bool = True,
        streaming: bool = False,
    ) -&gt; List[
        Union[AsyncGenerator[Any, Any], cybertensor.Synapse, cybertensor.StreamingSynapse]
    ]:
        &#34;&#34;&#34;
        Asynchronously sends requests to one or multiple Axons and collates their responses.

        This function acts as a bridge for sending multiple requests concurrently or sequentially
        based on the provided parameters. It checks the type of the target Axons, preprocesses
        the requests, and then sends them off. After getting the responses, it processes and
        collates them into a unified format.

        When querying an Axon that sends back data in chunks using the Dendrite, this function
        returns an AsyncGenerator that yields each chunk as it is received. The generator can be
        iterated over to process each chunk individually.

        For example:
            &gt;&gt;&gt; ...
            &gt;&gt;&gt; dendrte = cybertensor.dendrite(wallet = wallet)
            &gt;&gt;&gt; async for chunk in dendrite.forward(axons, synapse, timeout, deserialize, run_async, streaming):
            &gt;&gt;&gt;     # Process each chunk here
            &gt;&gt;&gt;     print(chunk)

        Args:
            axons (Union[List[Union[&#39;cybertensor.AxonInfo&#39;, &#39;cybertensor.axon&#39;]], Union[&#39;cybertensor.AxonInfo&#39;, &#39;cybertensor.axon&#39;]]):
                The target Axons to send requests to. Can be a single Axon or a list of Axons.
            synapse (cybertensor.Synapse, optional): The Synapse object encapsulating the data. Defaults to a new :func:`cybertensor.Synapse` instance.
            timeout (float, optional): Maximum duration to wait for a response from an Axon in seconds. Defaults to ``12.0``.
            deserialize (bool, optional): Determines if the received response should be deserialized. Defaults to ``True``.
            run_async (bool, optional): If True, sends requests concurrently. Otherwise, sends requests sequentially. Defaults to ``True``.
            streaming (bool, optional): Indicates if the response is expected to be in streaming format. Defaults to ``False``.

        Returns:
            Union[AsyncGenerator, cybertensor.Synapse, List[cybertensor.Synapse]]: If a single Axon is targeted, returns its response.
            If multiple Axons are targeted, returns a list of their responses.
        &#34;&#34;&#34;
        is_list = True
        # If a single axon is provided, wrap it in a list for uniform processing
        if not isinstance(axons, list):
            is_list = False
            axons = [axons]

        # Check if synapse is an instance of the StreamingSynapse class or if streaming flag is set.
        is_streaming_subclass = issubclass(
            synapse.__class__, cybertensor.StreamingSynapse
        )
        if streaming != is_streaming_subclass:
            cybertensor.logging.warning(
                f&#34;Argument streaming is {streaming} while issubclass(synapse, StreamingSynapse) is {synapse.__class__.__name__}. This may cause unexpected behavior.&#34;
            )
        streaming = is_streaming_subclass or streaming

        async def query_all_axons(
            is_stream: bool,
        ) -&gt; Union[
            AsyncGenerator[Any, Any], cybertensor.Synapse, cybertensor.StreamingSynapse
        ]:
            &#34;&#34;&#34;
            Manages the request and response process for a single axon, supporting both streaming and non-streaming modes.
            This function is responsible for initiating a request to a single axon. Depending on the
            ``is_stream`` flag, it either uses ``call_stream`` for streaming responses or ``call`` for
            standard responses. The function handles the response processing, catering to the specifics
            of streaming or non-streaming data.
            Args:
                target_axon: The target axon object to which the request is to be sent. This object contains
                    the necessary information like IP address and port to formulate the request.
            Returns:
                Union[AsyncGenerator, cybertensor.Synapse, cybertensor.StreamingSynapse]: The response from the targeted axon.
                    In streaming mode, an AsyncGenerator is returned, yielding data chunks. In non-streaming mode, a
                    Synapse or StreamingSynapse object is returned containing the response.
            &#34;&#34;&#34;

            async def single_axon_response(
                target_axon,
            ) -&gt; Union[
                AsyncGenerator[Any, Any], cybertensor.Synapse, cybertensor.StreamingSynapse
            ]:
                &#34;&#34;&#34;
                Retrieve response for a single axon, either in streaming or non-streaming mode.

                Args:
                    target_axon: The target axon to send request to.

                Returns:
                    A Synapse object with the response.
                &#34;&#34;&#34;
                if is_stream:
                    # If in streaming mode, return the async_generator
                    return self.call_stream(
                        target_axon=target_axon,
                        synapse=synapse.copy(),  # type: ignore
                        timeout=timeout,
                        deserialize=deserialize,
                    )
                else:
                    # If not in streaming mode, simply call the axon and get the response.
                    return await self.call(
                        target_axon=target_axon,
                        synapse=synapse.copy(),  # type: ignore
                        timeout=timeout,
                        deserialize=deserialize,
                    )

            # If run_async flag is False, get responses one by one.
            if not run_async:
                return [
                    await single_axon_response(target_axon) for target_axon in axons
                ]  # type: ignore
            # If run_async flag is True, get responses concurrently using asyncio.gather().
            return await asyncio.gather(
                *(single_axon_response(target_axon) for target_axon in axons)
            )  # type: ignore

        # Get responses for all axons.
        responses = await query_all_axons(streaming)
        # Return the single response if only one axon was targeted, else return all responses
        return responses[0] if len(responses) == 1 and not is_list else responses  # type: ignore

    async def call(
        self,
        target_axon: Union[cybertensor.AxonInfo, cybertensor.axon],
        synapse: cybertensor.Synapse = cybertensor.Synapse(),
        timeout: float = 12.0,
        deserialize: bool = True,
    ) -&gt; cybertensor.Synapse:
        &#34;&#34;&#34;
        Asynchronously sends a request to a specified Axon and processes the response.

        This function establishes a connection with a specified Axon, sends the encapsulated
        data through the Synapse object, waits for a response, processes it, and then
        returns the updated Synapse object.

        Args:
            target_axon (Union[&#39;cybertensor.AxonInfo&#39;, &#39;cybertensor.axon&#39;]): The target Axon to send the request to.
            synapse (cybertensor.Synapse, optional): The Synapse object encapsulating the data. Defaults to a new :func:`cybertensor.Synapse` instance.
            timeout (float, optional): Maximum duration to wait for a response from the Axon in seconds. Defaults to ``12.0``.
            deserialize (bool, optional): Determines if the received response should be deserialized. Defaults to ``True``.

        Returns:
            cybertensor.Synapse: The Synapse object, updated with the response data from the Axon.
        &#34;&#34;&#34;

        # Record start time
        start_time = time.time()
        target_axon = (
            target_axon.info()
            if isinstance(target_axon, cybertensor.axon)
            else target_axon
        )

        # Build request endpoint from the synapse class
        request_name = synapse.__class__.__name__
        url = self._get_endpoint_url(target_axon, request_name=request_name)

        # Preprocess synapse for making a request
        synapse = self.preprocess_synapse_for_request(target_axon, synapse, timeout)  # type: ignore

        try:
            # Log outgoing request
            self._log_outgoing_request(synapse)

            # Make the HTTP POST request
            async with (await self.session).post(
                url,
                headers=synapse.to_headers(),
                json=synapse.dict(),
                timeout=timeout,
            ) as response:
                # Extract the JSON response from the server
                json_response = await response.json()
                # Process the server response and fill synapse
                self.process_server_response(response, json_response, synapse)

            # Set process time and log the response
            synapse.dendrite.process_time = str(time.time() - start_time)

        except Exception as e:
            self._handle_request_errors(synapse, request_name, e)

        finally:
            self._log_incoming_response(synapse)

            # Log synapse event history
            self.synapse_history.append(
                cybertensor.Synapse.from_headers(synapse.to_headers())
            )

            # Return the updated synapse object after deserializing if requested
            if deserialize:
                return synapse.deserialize()
            else:
                return synapse

    async def call_stream(
        self,
        target_axon: Union[cybertensor.AxonInfo, cybertensor.axon],
        synapse: cybertensor.Synapse = cybertensor.Synapse(),  # type: ignore
        timeout: float = 12.0,
        deserialize: bool = True,
    ) -&gt; AsyncGenerator[Any, Any]:
        &#34;&#34;&#34;
        Sends a request to a specified Axon and yields streaming responses.

        Similar to ``call``, but designed for scenarios where the Axon sends back data in
        multiple chunks or streams. The function yields each chunk as it is received. This is
        useful for processing large responses piece by piece without waiting for the entire
        data to be transmitted.

        Args:
            target_axon (Union[&#39;cybertensor.AxonInfo&#39;, &#39;cybertensor.axon&#39;]): The target Axon to send the request to.
            synapse (cybertensor.Synapse, optional): The Synapse object encapsulating the data. Defaults to a
                new :func:`cybertensor.Synapse` instance.
            timeout (float, optional): Maximum duration to wait for a response (or a chunk of the response) from
                the Axon in seconds. Defaults to ``12.0``.
            deserialize (bool, optional): Determines if each received chunk should be deserialized. Defaults to ``True``.

        Yields:
            object: Each yielded object contains a chunk of the arbitrary response data from the Axon.
            cybertensor.Synapse: After the AsyncGenerator has been exhausted, yields the final filled Synapse.
        &#34;&#34;&#34;

        # Record start time
        start_time = time.time()
        target_axon = (
            target_axon.info()
            if isinstance(target_axon, cybertensor.axon)
            else target_axon
        )

        # Build request endpoint from the synapse class
        request_name = synapse.__class__.__name__
        endpoint = (
            f&#34;0.0.0.0:{str(target_axon.port)}&#34;
            if target_axon.ip == str(self.external_ip)
            else f&#34;{target_axon.ip}:{str(target_axon.port)}&#34;
        )
        url = f&#34;http://{endpoint}/{request_name}&#34;

        # Preprocess synapse for making a request
        synapse = self.preprocess_synapse_for_request(target_axon, synapse, timeout)  # type: ignore

        try:
            # Log outgoing request
            self._log_outgoing_request(synapse)

            # Make the HTTP POST request
            async with (await self.session).post(
                url,
                headers=synapse.to_headers(),
                json=synapse.dict(),
                timeout=timeout,
            ) as response:
                # Use synapse subclass&#39; process_streaming_response method to yield the response chunks
                async for chunk in synapse.process_streaming_response(response):  # type: ignore
                    yield chunk  # Yield each chunk as it&#39;s processed
                json_response = synapse.extract_response_json(response)

                # Process the server response
                self.process_server_response(response, json_response, synapse)

            # Set process time and log the response
            synapse.dendrite.process_time = str(time.time() - start_time)  # type: ignore

        except Exception as e:
            self._handle_request_errors(synapse, request_name, e)

        finally:
            self._log_incoming_response(synapse)

            # Log synapse event history
            self.synapse_history.append(
                cybertensor.Synapse.from_headers(synapse.to_headers())
            )

            # Return the updated synapse object after deserializing if requested
            if deserialize:
                yield synapse.deserialize()
            else:
                yield synapse

    def preprocess_synapse_for_request(
        self,
        target_axon_info: cybertensor.AxonInfo,
        synapse: cybertensor.Synapse,
        timeout: float = 12.0,
    ) -&gt; cybertensor.Synapse:
        &#34;&#34;&#34;
        Preprocesses the synapse for making a request. This includes building
        headers for Dendrite and Axon and signing the request.

        Args:
            target_axon_info (cybertensor.AxonInfo): The target axon information.
            synapse (cybertensor.Synapse): The synapse object to be preprocessed.
            timeout (float, optional): The request timeout duration in seconds.
                Defaults to ``12.0`` seconds.

        Returns:
            cybertensor.Synapse: The preprocessed synapse.
        &#34;&#34;&#34;
        # Set the timeout for the synapse
        synapse.timeout = timeout

        # Build the Dendrite headers using the local system&#39;s details
        synapse.dendrite = cybertensor.TerminalInfo(
            ip=self.external_ip,
            version=cybertensor.__version_as_int__,
            nonce=time.monotonic_ns(),
            uuid=self.uuid,
            hotkey=self.keypair.address,
            pubkey=self.keypair.public_key
        )

        # Build the Axon headers using the target axon&#39;s details
        synapse.axon = cybertensor.TerminalInfo(
            ip=target_axon_info.ip,
            port=target_axon_info.port,
            hotkey=target_axon_info.hotkey,
            pubkey=None
        )

        # Sign the request using the dendrite, axon info, and the synapse body hash
        message = f&#34;{synapse.dendrite.nonce}.{synapse.dendrite.hotkey}.{synapse.axon.hotkey}.{synapse.dendrite.uuid}.{synapse.body_hash}&#34;
        synapse.dendrite.signature = f&#34;0x{self.keypair.sign(message).hex()}&#34;

        return synapse

    def process_server_response(
        self,
        server_response: aiohttp.ClientResponse,
        json_response: dict,
        local_synapse: cybertensor.Synapse,
    ):
        &#34;&#34;&#34;
        Processes the server response, updates the local synapse state with the
        server&#39;s state and merges headers set by the server.

        Args:
            server_response (object): The `aiohttp &lt;https://github.com/aio-libs/aiohttp&gt;`_ response object from the server.
            json_response (dict): The parsed JSON response from the server.
            local_synapse (cybertensor.Synapse): The local synapse object to be updated.

        Raises:
            None: But errors in attribute setting are silently ignored.
        &#34;&#34;&#34;
        # Check if the server responded with a successful status code
        if server_response.status == 200:
            # If the response is successful, overwrite local synapse state with
            # server&#39;s state only if the protocol allows mutation. To prevent overwrites,
            # the protocol must set allow_mutation = False
            server_synapse = local_synapse.__class__(**json_response)
            for key in local_synapse.dict().keys():
                try:
                    # Set the attribute in the local synapse from the corresponding
                    # attribute in the server synapse
                    setattr(local_synapse, key, getattr(server_synapse, key))
                except:
                    # Ignore errors during attribute setting
                    pass

        # Extract server headers and overwrite None values in local synapse headers
        server_headers = cybertensor.Synapse.from_headers(server_response.headers)  # type: ignore

        # Merge dendrite headers
        local_synapse.dendrite.__dict__.update(
            {
                **local_synapse.dendrite.dict(exclude_none=True),  # type: ignore
                **server_headers.dendrite.dict(exclude_none=True),  # type: ignore
            }
        )

        # Merge axon headers
        local_synapse.axon.__dict__.update(
            {
                **local_synapse.axon.dict(exclude_none=True),  # type: ignore
                **server_headers.axon.dict(exclude_none=True),  # type: ignore
            }
        )

        # Update the status code and status message of the dendrite to match the axon
        local_synapse.dendrite.status_code = local_synapse.axon.status_code  # type: ignore
        local_synapse.dendrite.status_message = local_synapse.axon.status_message  # type: ignore

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Returns a string representation of the Dendrite object.

        Returns:
            str: The string representation of the Dendrite object in the format :func:`dendrite(&lt;user_wallet_address&gt;)`.
        &#34;&#34;&#34;
        return &#34;dendrite({})&#34;.format(self.keypair.address)

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Returns a string representation of the Dendrite object, acting as a fallback for :func:`__str__()`.

        Returns:
            str: The string representation of the Dendrite object in the format :func:`dendrite(&lt;user_wallet_address&gt;)`.
        &#34;&#34;&#34;
        return self.__str__()

    async def __aenter__(self):
        &#34;&#34;&#34;
        Asynchronous context manager entry method.

        Enables the use of the ``async with`` statement with the Dendrite instance. When entering the context,
        the current instance of the class is returned, making it accessible within the asynchronous context.

        Returns:
            Dendrite: The current instance of the Dendrite class.

        Usage::
            async with Dendrite() as dendrite:
                await dendrite.some_async_method()
        &#34;&#34;&#34;
        return self

    async def __aexit__(self, exc_type, exc_value, traceback):
        &#34;&#34;&#34;
        Asynchronous context manager exit method.

        Ensures proper cleanup when exiting the ``async with`` context. This method will close
        the `aiohttp &lt;https://github.com/aio-libs/aiohttp&gt;`_ client session

        Args:
            exc_type (Type[BaseException], optional): The type of exception that was raised.
            exc_value (BaseException, optional): The instance of exception that was raised.
            traceback (TracebackType, optional): A traceback object encapsulating the call stack at the point
                where the exception was raised.

        Usage::
            async with ct.dendrite( wallet ) as dendrite:
                await dendrite.some_async_method()
        Note:
            This automatically closes the session by calling :func:`__aexit__` after the context closes.
        &#34;&#34;&#34;
        await self.aclose_session()

    def __del__(self):
        &#34;&#34;&#34;
        Dendrite destructor.

        This method is invoked when the Dendrite instance is about to be destroyed. The destructor ensures that the
        aiohttp client session is closed before the instance is fully destroyed, releasing any remaining resources.

        Note: Relying on the destructor for cleanup can be unpredictable. It&#39;s recommended to explicitly close sessions
        using the provided methods or the ``async with`` context manager.

        Usage::
            dendrite = Dendrite()
            # ... some operations ...
            del dendrite  # This will implicitly invoke the __del__ method.
        &#34;&#34;&#34;
        self.close_session()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>torch.nn.modules.module.Module</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="cybertensor.dendrite.dendrite.session"><code class="name">prop <span class="ident">session</span> : aiohttp.ClientSession</code></dt>
<dd>
<div class="desc"><p>An asynchronous property that provides access to the internal <code>aiohttp &lt;https://github.com/aio-libs/aiohttp&gt;</code><em> client session.
This property ensures the management of HTTP connections in an efficient way. It lazily
initializes the <code>aiohttp.ClientSession &lt;https://docs.aiohttp.org/en/stable/client_reference.html#aiohttp.ClientSession&gt;</code></em>
on its first use. The session is then reused for subsequent HTTP requests, offering performance benefits by
reusing underlying connections.
This is used internally by the dendrite when querying axons, and should not be used directly
unless absolutely necessary for your application.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>aiohttp.ClientSession</code></dt>
<dd>The active <code>aiohttp &lt;https://github.com/aio-libs/aiohttp&gt;</code>_ client session instance.</dd>
</dl>
<p>If no session exists, a new one is created and returned. This session is used for asynchronous HTTP requests
within the dendrite, adhering to the async nature of the network interactions in the cybertensor framework.
Example usage::
import cybertensor as ct
# Import cybertensor
wallet = ct.Wallet( &hellip; )
# Initialize a wallet
dendrite = ct.dendrite( wallet )
# Initialize a dendrite instance with the wallet
async with (await dendrite.session).post( # Use the session to make an HTTP POST request
url,
# URL to send the request to
headers={&hellip;},
# Headers dict to be sent with the request
json={&hellip;},
# JSON body data to be sent with the request
timeout=10,
# Timeout duration in seconds
) as response:
json_response = await response.json() # Extract the JSON response from the server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
async def session(self) -&gt; aiohttp.ClientSession:
    &#34;&#34;&#34;
    An asynchronous property that provides access to the internal `aiohttp &lt;https://github.com/aio-libs/aiohttp&gt;`_ client session.
    This property ensures the management of HTTP connections in an efficient way. It lazily
    initializes the `aiohttp.ClientSession &lt;https://docs.aiohttp.org/en/stable/client_reference.html#aiohttp.ClientSession&gt;`_
    on its first use. The session is then reused for subsequent HTTP requests, offering performance benefits by
    reusing underlying connections.
    This is used internally by the dendrite when querying axons, and should not be used directly
    unless absolutely necessary for your application.
    Returns:
        aiohttp.ClientSession: The active `aiohttp &lt;https://github.com/aio-libs/aiohttp&gt;`_ client session instance.
        If no session exists, a new one is created and returned. This session is used for asynchronous HTTP requests
        within the dendrite, adhering to the async nature of the network interactions in the cybertensor framework.
    Example usage::
        import cybertensor as ct                    # Import cybertensor
        wallet = ct.Wallet( ... )                 # Initialize a wallet
        dendrite = ct.dendrite( wallet )          # Initialize a dendrite instance with the wallet
        async with (await dendrite.session).post( # Use the session to make an HTTP POST request
            url,                                  # URL to send the request to
            headers={...},                        # Headers dict to be sent with the request
            json={...},                           # JSON body data to be sent with the request
            timeout=10,                           # Timeout duration in seconds
        ) as response:
            json_response = await response.json() # Extract the JSON response from the server
    &#34;&#34;&#34;
    if self._session is None:
        self._session = aiohttp.ClientSession()
    return self._session</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="cybertensor.dendrite.dendrite.aclose_session"><code class="name flex">
<span>async def <span class="ident">aclose_session</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Asynchronously closes the internal <code>aiohttp &lt;https://github.com/aio-libs/aiohttp&gt;</code>_ client session.
This method is the asynchronous counterpart to the :func:<code>close_session</code> method. It should be used in
asynchronous contexts to ensure that the aiohttp client session is closed properly. The method
releases resources associated with the session, such as open connections and internal buffers,
which is essential for resource management in asynchronous applications.</p>
<h2 id="usage">Usage</h2>
<p>When finished with dendrite in an asynchronous context
await :func:<code>dendrite_instance.aclose_session()</code>.
Example::
async with dendrite_instance:
# Operations using dendrite
pass
# The session will be closed automatically after the above block</p></div>
</dd>
<dt id="cybertensor.dendrite.dendrite.call"><code class="name flex">
<span>async def <span class="ident">call</span></span>(<span>self, target_axon: Union[cybertensor.AxonInfo, <a title="cybertensor.axon" href="axon.html">cybertensor.axon</a>], synapse: cybertensor.Synapse = Synapse(), timeout: float = 12.0, deserialize: bool = True) ‑> <a title="cybertensor.synapse.Synapse" href="synapse.html#cybertensor.synapse.Synapse">Synapse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Asynchronously sends a request to a specified Axon and processes the response.</p>
<p>This function establishes a connection with a specified Axon, sends the encapsulated
data through the Synapse object, waits for a response, processes it, and then
returns the updated Synapse object.</p>
<h2 id="args">Args</h2>
<dl>
<dt>target_axon (Union['cybertensor.AxonInfo', 'cybertensor.axon']): The target Axon to send the request to.</dt>
<dt><strong><code>synapse</code></strong> :&ensp;<code>cybertensor.Synapse</code>, optional</dt>
<dd>The Synapse object encapsulating the data. Defaults to a new :func:<code>cybertensor.Synapse</code> instance.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Maximum duration to wait for a response from the Axon in seconds. Defaults to <code>12.0</code>.</dd>
<dt><strong><code>deserialize</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Determines if the received response should be deserialized. Defaults to <code>True</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>cybertensor.Synapse</code></dt>
<dd>The Synapse object, updated with the response data from the Axon.</dd>
</dl></div>
</dd>
<dt id="cybertensor.dendrite.dendrite.call_stream"><code class="name flex">
<span>async def <span class="ident">call_stream</span></span>(<span>self, target_axon: Union[cybertensor.AxonInfo, <a title="cybertensor.axon" href="axon.html">cybertensor.axon</a>], synapse: cybertensor.Synapse = Synapse(), timeout: float = 12.0, deserialize: bool = True) ‑> AsyncGenerator[Any, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Sends a request to a specified Axon and yields streaming responses.</p>
<p>Similar to <code>call</code>, but designed for scenarios where the Axon sends back data in
multiple chunks or streams. The function yields each chunk as it is received. This is
useful for processing large responses piece by piece without waiting for the entire
data to be transmitted.</p>
<h2 id="args">Args</h2>
<dl>
<dt>target_axon (Union['cybertensor.AxonInfo', 'cybertensor.axon']): The target Axon to send the request to.</dt>
<dt><strong><code>synapse</code></strong> :&ensp;<code>cybertensor.Synapse</code>, optional</dt>
<dd>The Synapse object encapsulating the data. Defaults to a
new :func:<code>cybertensor.Synapse</code> instance.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Maximum duration to wait for a response (or a chunk of the response) from
the Axon in seconds. Defaults to <code>12.0</code>.</dd>
<dt><strong><code>deserialize</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Determines if each received chunk should be deserialized. Defaults to <code>True</code>.</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>object</code></dt>
<dd>Each yielded object contains a chunk of the arbitrary response data from the Axon.</dd>
<dt><code>cybertensor.Synapse</code></dt>
<dd>After the AsyncGenerator has been exhausted, yields the final filled Synapse.</dd>
</dl></div>
</dd>
<dt id="cybertensor.dendrite.dendrite.close_session"><code class="name flex">
<span>def <span class="ident">close_session</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Closes the internal <code>aiohttp &lt;https://github.com/aio-libs/aiohttp&gt;</code>_ client session synchronously.
This method ensures the proper closure and cleanup of the aiohttp client session, releasing any
resources like open connections and internal buffers. It is crucial for preventing resource leakage
and should be called when the dendrite instance is no longer in use, especially in synchronous contexts.</p>
<h2 id="note">Note</h2>
<p>This method utilizes asyncio's event loop to close the session asynchronously from a synchronous context.
It is advisable to use this method only when asynchronous context management is not feasible.</p>
<h2 id="usage">Usage</h2>
<p>When finished with dendrite in a synchronous context
:func:<code>dendrite_instance.close_session()</code>.</p></div>
</dd>
<dt id="cybertensor.dendrite.dendrite.forward"><code class="name flex">
<span>async def <span class="ident">forward</span></span>(<span>self, axons: Union[List[Union[cybertensor.AxonInfo, <a title="cybertensor.axon" href="axon.html">cybertensor.axon</a>]], Union[cybertensor.AxonInfo, <a title="cybertensor.axon" href="axon.html">cybertensor.axon</a>]], synapse: cybertensor.Synapse = Synapse(), timeout: float = 12, deserialize: bool = True, run_async: bool = True, streaming: bool = False) ‑> List[Union[AsyncGenerator[Any, Any], <a title="cybertensor.synapse.Synapse" href="synapse.html#cybertensor.synapse.Synapse">Synapse</a>, <a title="cybertensor.stream.StreamingSynapse" href="stream.html#cybertensor.stream.StreamingSynapse">StreamingSynapse</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Asynchronously sends requests to one or multiple Axons and collates their responses.</p>
<p>This function acts as a bridge for sending multiple requests concurrently or sequentially
based on the provided parameters. It checks the type of the target Axons, preprocesses
the requests, and then sends them off. After getting the responses, it processes and
collates them into a unified format.</p>
<p>When querying an Axon that sends back data in chunks using the Dendrite, this function
returns an AsyncGenerator that yields each chunk as it is received. The generator can be
iterated over to process each chunk individually.</p>
<p>For example:
&gt;&gt;&gt; &hellip;
&gt;&gt;&gt; dendrte = cybertensor.dendrite(wallet = wallet)
&gt;&gt;&gt; async for chunk in dendrite.forward(axons, synapse, timeout, deserialize, run_async, streaming):
&gt;&gt;&gt;
# Process each chunk here
&gt;&gt;&gt;
print(chunk)</p>
<h2 id="args">Args</h2>
<dl>
<dt>axons (Union[List[Union['cybertensor.AxonInfo', 'cybertensor.axon']], Union['cybertensor.AxonInfo', 'cybertensor.axon']]):</dt>
<dt>The target Axons to send requests to. Can be a single Axon or a list of Axons.</dt>
<dt><strong><code>synapse</code></strong> :&ensp;<code>cybertensor.Synapse</code>, optional</dt>
<dd>The Synapse object encapsulating the data. Defaults to a new :func:<code>cybertensor.Synapse</code> instance.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Maximum duration to wait for a response from an Axon in seconds. Defaults to <code>12.0</code>.</dd>
<dt><strong><code>deserialize</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Determines if the received response should be deserialized. Defaults to <code>True</code>.</dd>
<dt><strong><code>run_async</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, sends requests concurrently. Otherwise, sends requests sequentially. Defaults to <code>True</code>.</dd>
<dt><strong><code>streaming</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Indicates if the response is expected to be in streaming format. Defaults to <code>False</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[AsyncGenerator, cybertensor.Synapse, List[cybertensor.Synapse]]</code></dt>
<dd>If a single Axon is targeted, returns its response.</dd>
</dl>
<p>If multiple Axons are targeted, returns a list of their responses.</p></div>
</dd>
<dt id="cybertensor.dendrite.dendrite.preprocess_synapse_for_request"><code class="name flex">
<span>def <span class="ident">preprocess_synapse_for_request</span></span>(<span>self, target_axon_info: cybertensor.AxonInfo, synapse: cybertensor.Synapse, timeout: float = 12.0) ‑> <a title="cybertensor.synapse.Synapse" href="synapse.html#cybertensor.synapse.Synapse">Synapse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Preprocesses the synapse for making a request. This includes building
headers for Dendrite and Axon and signing the request.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target_axon_info</code></strong> :&ensp;<code>cybertensor.AxonInfo</code></dt>
<dd>The target axon information.</dd>
<dt><strong><code>synapse</code></strong> :&ensp;<code>cybertensor.Synapse</code></dt>
<dd>The synapse object to be preprocessed.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The request timeout duration in seconds.
Defaults to <code>12.0</code> seconds.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>cybertensor.Synapse</code></dt>
<dd>The preprocessed synapse.</dd>
</dl></div>
</dd>
<dt id="cybertensor.dendrite.dendrite.process_server_response"><code class="name flex">
<span>def <span class="ident">process_server_response</span></span>(<span>self, server_response: aiohttp.ClientResponse, json_response: dict, local_synapse: cybertensor.Synapse)</span>
</code></dt>
<dd>
<div class="desc"><p>Processes the server response, updates the local synapse state with the
server's state and merges headers set by the server.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>server_response</code></strong> :&ensp;<code>object</code></dt>
<dd>The <code>aiohttp &lt;https://github.com/aio-libs/aiohttp&gt;</code>_ response object from the server.</dd>
<dt><strong><code>json_response</code></strong> :&ensp;<code>dict</code></dt>
<dd>The parsed JSON response from the server.</dd>
<dt><strong><code>local_synapse</code></strong> :&ensp;<code>cybertensor.Synapse</code></dt>
<dd>The local synapse object to be updated.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>None</code></dt>
<dd>But errors in attribute setting are silently ignored.</dd>
</dl></div>
</dd>
<dt id="cybertensor.dendrite.dendrite.query"><code class="name flex">
<span>def <span class="ident">query</span></span>(<span>self, *args, **kwargs) ‑> List[Union[AsyncGenerator[Any, Any], <a title="cybertensor.synapse.Synapse" href="synapse.html#cybertensor.synapse.Synapse">Synapse</a>, <a title="cybertensor.stream.StreamingSynapse" href="stream.html#cybertensor.stream.StreamingSynapse">StreamingSynapse</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Makes a synchronous request to multiple target Axons and returns the server responses.</p>
<p>Cleanup is automatically handled and sessions are closed upon completed requests.</p>
<h2 id="args">Args</h2>
<dl>
<dt>axons (Union[List[Union['cybertensor.AxonInfo', 'cybertensor.axon']], Union['cybertensor.AxonInfo', 'cybertensor.axon']]):</dt>
<dt>The list of target Axon information.</dt>
<dt><strong><code>synapse</code></strong> :&ensp;<code>cybertensor.Synapse</code>, optional</dt>
<dd>The Synapse object. Defaults to cybertensor.Synapse().</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The request timeout duration in seconds.
Defaults to 12.0 seconds.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[cybertensor.Synapse, List[cybertensor.Synapse]]</code></dt>
<dd>If a single target axon is provided, returns the response
from that axon. If multiple target axons are provided, returns a list of responses from all target axons.</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cybertensor" href="index.html">cybertensor</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cybertensor.dendrite.dendrite" href="#cybertensor.dendrite.dendrite">dendrite</a></code></h4>
<ul class="">
<li><code><a title="cybertensor.dendrite.dendrite.aclose_session" href="#cybertensor.dendrite.dendrite.aclose_session">aclose_session</a></code></li>
<li><code><a title="cybertensor.dendrite.dendrite.call" href="#cybertensor.dendrite.dendrite.call">call</a></code></li>
<li><code><a title="cybertensor.dendrite.dendrite.call_stream" href="#cybertensor.dendrite.dendrite.call_stream">call_stream</a></code></li>
<li><code><a title="cybertensor.dendrite.dendrite.close_session" href="#cybertensor.dendrite.dendrite.close_session">close_session</a></code></li>
<li><code><a title="cybertensor.dendrite.dendrite.forward" href="#cybertensor.dendrite.dendrite.forward">forward</a></code></li>
<li><code><a title="cybertensor.dendrite.dendrite.preprocess_synapse_for_request" href="#cybertensor.dendrite.dendrite.preprocess_synapse_for_request">preprocess_synapse_for_request</a></code></li>
<li><code><a title="cybertensor.dendrite.dendrite.process_server_response" href="#cybertensor.dendrite.dendrite.process_server_response">process_server_response</a></code></li>
<li><code><a title="cybertensor.dendrite.dendrite.query" href="#cybertensor.dendrite.dendrite.query">query</a></code></li>
<li><code><a title="cybertensor.dendrite.dendrite.session" href="#cybertensor.dendrite.dendrite.session">session</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
