<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>cybertensor.commands.delegates API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cybertensor.commands.delegates</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="cybertensor.commands.delegates.show_delegates"><code class="name flex">
<span>def <span class="ident">show_delegates</span></span>(<span>config: Config, delegates: List[ForwardRef('cybertensor.DelegateInfo')], prev_delegates: Optional[List[ForwardRef('cybertensor.DelegateInfo')]], width: Optional[int] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays a formatted table of Cybertensor network delegates with detailed statistics
to the console. The table is sorted by total stake in descending order and provides
a snapshot of delegate performance and status, helping users make informed decisions
for staking or nominating.</p>
<p>This is a helper function that is called by the 'list_delegates' and 'my_delegates'
and not intended to be used directly in user code unless specifically required.</p>
<p>Parameters:
- delegates (List[cybertensor.DelegateInfo]): A list of delegate information objects
to be displayed.
- prev_delegates (Optional[List[cybertensor.DelegateInfo]]): A list of delegate
information objects from a previous state, used to calculate changes in stake.
Defaults to None.
- width (Optional[int]): The width of the console output table. Defaults to None,
which will make the table expand to the maximum width of the console.</p>
<p>The output table includes the following columns:
- INDEX: The numerical index of the delegate.
- DELEGATE: The name of the delegate.
- ADDR: The truncated address of the delegate.
- NOMINATORS: The number of nominators supporting the delegate.
- DELEGATE STAKE(τ): The stake that is directly delegated to the delegate.
- TOTAL STAKE(τ): The total stake held by the delegate, including nominators' stake.
- CHANGE/(4h): The percentage change in the delegate's stake over the past 4 hours.
- SUBNETS: A list of subnets the delegate is registered with.
- VPERMIT: Validator permits held by the delegate for the subnets.
- NOMINATOR/(24h)/kτ: The earnings per 1000 τ staked by nominators in the last 24 hours.
- DELEGATE/(24h): The earnings of the delegate in the last 24 hours.
- Desc: A brief description provided by the delegate.</p>
<p>Usage:
This function is typically used within the Cybertensor CLI to show current delegate
options to users who are considering where to stake their tokens.</p>
<p>Example usage:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; show_delegates(current_delegates, previous_delegates, width=80)
</code></pre>
<p>Note:
This function is primarily for display purposes within a command-line interface and does
not return any values. It relies on the 'rich' Python library to render the table in the
console.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cybertensor.commands.delegates.DelegateStakeCommand"><code class="flex name class">
<span>class <span class="ident">DelegateStakeCommand</span></span>
</code></dt>
<dd>
<div class="desc"><p>Executes the 'delegate' command, which stakes GBOOT to a specified delegate on the
Cybertensor network. This action allocates the user's GBOOT to support a delegate,
potentially earning staking rewards in return.</p>
<p>Optional Arguments:
- wallet.name: The name of the wallet to use for the command.
- delegatekey: The address of the delegate to stake to.
- amount: The amount of GBOOT to stake.
- all: If specified, the command stakes all available GBOOT.</p>
<p>The command interacts with the user to determine the delegate and the amount of GBOOT
to be staked. If the '&ndash;all' flag is used, it delegates the entire available balance.</p>
<p>Usage:
The user must specify the delegate's address and the amount of GBOOT to stake. The
function sends a transaction to the cwtensor network to delegate the specified amount
to the chosen delegate. These values are prompted if not provided.</p>
<p>Example usage:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ctcli delegate --delegatekey &lt;ADDRESS&gt; --amount &lt;AMOUNT&gt;
&gt;&gt;&gt; ctcli delegate --delegatekey &lt;ADDRESS&gt; --all
</code></pre>
<p>Note:
This command modifies the blockchain state and may incur transaction fees. It requires
user confirmation and interaction, and is designed to be used within the Cybertensor CLI
environment. The user should ensure the delegate's address and the amount to be staked
are correct before executing the command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DelegateStakeCommand:
    &#34;&#34;&#34;
    Executes the &#39;delegate&#39; command, which stakes GBOOT to a specified delegate on the
    Cybertensor network. This action allocates the user&#39;s GBOOT to support a delegate,
    potentially earning staking rewards in return.

    Optional Arguments:
    - wallet.name: The name of the wallet to use for the command.
    - delegatekey: The address of the delegate to stake to.
    - amount: The amount of GBOOT to stake.
    - all: If specified, the command stakes all available GBOOT.

    The command interacts with the user to determine the delegate and the amount of GBOOT
    to be staked. If the &#39;--all&#39; flag is used, it delegates the entire available balance.

    Usage:
    The user must specify the delegate&#39;s address and the amount of GBOOT to stake. The
    function sends a transaction to the cwtensor network to delegate the specified amount
    to the chosen delegate. These values are prompted if not provided.

    Example usage:
    &gt;&gt;&gt; ctcli delegate --delegatekey &lt;ADDRESS&gt; --amount &lt;AMOUNT&gt;
    &gt;&gt;&gt; ctcli delegate --delegatekey &lt;ADDRESS&gt; --all

    Note:
    This command modifies the blockchain state and may incur transaction fees. It requires
    user confirmation and interaction, and is designed to be used within the Cybertensor CLI
    environment. The user should ensure the delegate&#39;s address and the amount to be staked
    are correct before executing the command.
    &#34;&#34;&#34;

    @staticmethod
    def run(cli: &#34;cybertensor.cli&#34;):
        &#34;&#34;&#34;Delegates stake to a chain delegate.&#34;&#34;&#34;
        try:
            config = cli.config.copy()
            wallet = Wallet(config=config)
            cwtensor = cybertensor.cwtensor(config=config, log_verbose=False)
            cwtensor.delegate(
                wallet=wallet,
                delegate=config.get(&#34;delegatekey&#34;),
                amount=config.get(&#34;amount&#34;),
                wait_for_finalization=True,
                prompt=not config.no_prompt,
            )
        finally:
            if &#34;cwtensor&#34; in locals():
                cwtensor.close()
                cybertensor.logging.debug(&#34;closing cwtensor connection&#34;)

    @staticmethod
    def add_args(parser: argparse.ArgumentParser):
        delegate_stake_parser = parser.add_parser(
            &#34;delegate&#34;, help=&#34;&#34;&#34;Delegate Stake to an account.&#34;&#34;&#34;
        )
        delegate_stake_parser.add_argument(
            &#34;--delegatekey&#34;,
            &#34;--delegate&#34;,
            dest=&#34;delegatekey&#34;,
            type=str,
            required=False,
            help=&#34;&#34;&#34;The address of the chosen delegate&#34;&#34;&#34;,
        )
        delegate_stake_parser.add_argument(
            &#34;--all&#34;, dest=&#34;stake_all&#34;, action=&#34;store_true&#34;
        )
        delegate_stake_parser.add_argument(
            &#34;--amount&#34;, dest=&#34;amount&#34;, type=float, required=False
        )
        Wallet.add_args(delegate_stake_parser)
        cybertensor.cwtensor.add_args(delegate_stake_parser)

    @staticmethod
    def check_config(config: &#34;Config&#34;):
        if not config.get(&#34;delegatekey&#34;):
            # Check for delegates.
            with console.status(&#34;:satellite: Loading delegates...&#34;):
                cwtensor = cybertensor.cwtensor(config=config, log_verbose=False)
                delegates: List[cybertensor.DelegateInfo] = cwtensor.get_delegates()
                try:
                    prev_delegates = cwtensor.get_delegates(
                        max(0, cwtensor.block - 1200)
                    )
                except RuntimeError:
                    prev_delegates = None

            if prev_delegates is None:
                console.print(
                    &#34;:warning: [yellow]Could not fetch delegates history[/yellow]&#34;
                )

            if len(delegates) == 0:
                console.print(
                    f&#34;:cross_mark: [red]There are no delegates on {cwtensor.network}[/red]&#34;
                )
                sys.exit(1)

            delegates.sort(key=lambda delegate: delegate.total_stake, reverse=True)
            show_delegates(config, delegates, prev_delegates=prev_delegates)
            delegate_index = Prompt.ask(&#34;Enter delegate index&#34;)
            config.delegatekey = str(delegates[int(delegate_index)].hotkey)
            console.print(
                &#34;Selected: [yellow]{}[/yellow]&#34;.format(config.delegatekey)
            )

        if not config.is_set(&#34;wallet.name&#34;) and not config.no_prompt:
            wallet_name = Prompt.ask(&#34;Enter wallet name&#34;, default=defaults.wallet.name)
            config.wallet.name = str(wallet_name)

        # Get amount.
        if not config.get(&#34;amount&#34;) and not config.get(&#34;stake_all&#34;):
            amount = Prompt.ask(f&#34;Enter {cwtensor.giga_token_symbol} amount to stake&#34;)
            try:
                config.amount = float(amount)
            except ValueError:
                console.print(
                    f&#34;:cross_mark: [red]Invalid {cwtensor.giga_token_symbol} amount[/red] &#34;
                    f&#34;[bold white]{amount}[/bold white]&#34;
                )
                sys.exit()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="cybertensor.commands.delegates.DelegateStakeCommand.add_args"><code class="name flex">
<span>def <span class="ident">add_args</span></span>(<span>parser: argparse.ArgumentParser)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cybertensor.commands.delegates.DelegateStakeCommand.check_config"><code class="name flex">
<span>def <span class="ident">check_config</span></span>(<span>config: Config)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cybertensor.commands.delegates.DelegateStakeCommand.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>cli: <a title="cybertensor.cli" href="../cli.html">cybertensor.cli</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Delegates stake to a chain delegate.</p></div>
</dd>
</dl>
</dd>
<dt id="cybertensor.commands.delegates.DelegateUnstakeCommand"><code class="flex name class">
<span>class <span class="ident">DelegateUnstakeCommand</span></span>
</code></dt>
<dd>
<div class="desc"><p>Executes the 'undelegate' command, allowing users to withdraw their staked GBOOT from
a delegate on the Cybertensor network. This process is known as "undelegating" and it
reverses the delegation process, freeing up the staked tokens.</p>
<p>Optional Arguments:
- wallet.name: The name of the wallet to use for the command.
- delegatekey: The address of the delegate to undelegate from.
- amount: The amount of GBOOT to undelegate.
- all: If specified, the command undelegates all staked GBOOT from the delegate.</p>
<p>The command prompts the user for the amount of GBOOT to undelegate and the address
of the delegate from which to undelegate. If the '&ndash;all' flag is used, it will attempt
to undelegate the entire staked amount from the specified delegate.</p>
<p>Usage:
The user must provide the delegate's address and the amount of GBOOT to undelegate.
The function will then send a transaction to the Cybertensor network to process the
undelegation.</p>
<p>Example usage:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ctcli undelegate --delegatekey &lt;ADDRESS&gt; --amount &lt;AMOUNT&gt;
&gt;&gt;&gt; ctcli undelegate --delegatekey &lt;ADDRESS&gt; --all
</code></pre>
<p>Note:
This command can result in a change to the blockchain state and may incur transaction
fees. It is interactive and requires confirmation from the user before proceeding. It
should be used with care as undelegating can affect the delegate's total stake and
potentially the user's staking rewards.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DelegateUnstakeCommand:
    &#34;&#34;&#34;
    Executes the &#39;undelegate&#39; command, allowing users to withdraw their staked GBOOT from
    a delegate on the Cybertensor network. This process is known as &#34;undelegating&#34; and it
    reverses the delegation process, freeing up the staked tokens.

    Optional Arguments:
    - wallet.name: The name of the wallet to use for the command.
    - delegatekey: The address of the delegate to undelegate from.
    - amount: The amount of GBOOT to undelegate.
    - all: If specified, the command undelegates all staked GBOOT from the delegate.

    The command prompts the user for the amount of GBOOT to undelegate and the address
    of the delegate from which to undelegate. If the &#39;--all&#39; flag is used, it will attempt
    to undelegate the entire staked amount from the specified delegate.

    Usage:
    The user must provide the delegate&#39;s address and the amount of GBOOT to undelegate.
    The function will then send a transaction to the Cybertensor network to process the
    undelegation.

    Example usage:
    &gt;&gt;&gt; ctcli undelegate --delegatekey &lt;ADDRESS&gt; --amount &lt;AMOUNT&gt;
    &gt;&gt;&gt; ctcli undelegate --delegatekey &lt;ADDRESS&gt; --all

    Note:
    This command can result in a change to the blockchain state and may incur transaction
    fees. It is interactive and requires confirmation from the user before proceeding. It
    should be used with care as undelegating can affect the delegate&#39;s total stake and
    potentially the user&#39;s staking rewards.
    &#34;&#34;&#34;

    @staticmethod
    def run(cli: &#34;cybertensor.cli&#34;):
        &#34;&#34;&#34;Undelegates stake from a chain delegate.&#34;&#34;&#34;
        try:
            config = cli.config.copy()
            wallet = Wallet(config=config)
            cwtensor = cybertensor.cwtensor(config=config, log_verbose=False)
            cwtensor.undelegate(
                wallet=wallet,
                delegate=config.get(&#34;delegatekey&#34;),
                amount=config.get(&#34;amount&#34;),
                wait_for_finalization=True,
                prompt=not config.no_prompt,
            )
        finally:
            if &#34;cwtensor&#34; in locals():
                cwtensor.close()
                cybertensor.logging.debug(&#34;closing cwtensor connection&#34;)


    @staticmethod
    def add_args(parser: argparse.ArgumentParser):
        undelegate_stake_parser = parser.add_parser(
            &#34;undelegate&#34;, help=&#34;&#34;&#34;Undelegate Stake from an account.&#34;&#34;&#34;
        )
        undelegate_stake_parser.add_argument(
            &#34;--delegatekey&#34;,
            &#34;--delegate&#34;,
            dest=&#34;delegatekey&#34;,
            type=str,
            required=False,
            help=&#34;&#34;&#34;The address of the choosen delegate&#34;&#34;&#34;,
        )
        undelegate_stake_parser.add_argument(
            &#34;--all&#34;, dest=&#34;unstake_all&#34;, action=&#34;store_true&#34;
        )
        undelegate_stake_parser.add_argument(
            &#34;--amount&#34;, dest=&#34;amount&#34;, type=float, required=False
        )
        Wallet.add_args(undelegate_stake_parser)
        cybertensor.cwtensor.add_args(undelegate_stake_parser)

    @staticmethod
    def check_config(config: &#34;Config&#34;):
        if not config.is_set(&#34;wallet.name&#34;) and not config.no_prompt:
            wallet_name = Prompt.ask(&#34;Enter wallet name&#34;, default=defaults.wallet.name)
            config.wallet.name = str(wallet_name)

        if not config.get(&#34;delegatekey&#34;):
            # Check for delegates.
            with console.status(&#34;:satellite: Loading delegates...&#34;):
                cwtensor = cybertensor.cwtensor(config=config, log_verbose=False)
                delegates: List[cybertensor.DelegateInfo] = cwtensor.get_delegates()
                try:
                    prev_delegates = cwtensor.get_delegates(
                        max(0, cwtensor.block - 1200)
                    )
                except RuntimeError:
                    prev_delegates = None

            if prev_delegates is None:
                console.print(
                    &#34;:warning: [yellow]Could not fetch delegates history[/yellow]&#34;
                )

            if len(delegates) == 0:
                console.print(
                    f&#34;:cross_mark: [red]There are no delegates on {cwtensor.network}[/red]&#34;
                )
                sys.exit(1)

            delegates.sort(key=lambda delegate: delegate.total_stake, reverse=True)
            show_delegates(config, delegates, prev_delegates=prev_delegates)
            delegate_index = Prompt.ask(&#34;Enter delegate index&#34;)
            config.delegatekey = str(delegates[int(delegate_index)].hotkey)
            console.print(f&#34;Selected: [yellow]{config.delegatekey}[/yellow]&#34;)

        # Get amount.
        if not config.get(&#34;amount&#34;) and not config.get(&#34;unstake_all&#34;):
            amount = Prompt.ask(f&#34;Enter {cwtensor.giga_token_symbol} amount to unstake&#34;)
            try:
                config.amount = float(amount)
            except ValueError:
                console.print(
                    f&#34;:cross_mark: [red]Invalid {cwtensor.giga_token_symbol} amount[/red] &#34;
                    f&#34;[bold white]{amount}[/bold white]&#34;
                )
                sys.exit()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="cybertensor.commands.delegates.DelegateUnstakeCommand.add_args"><code class="name flex">
<span>def <span class="ident">add_args</span></span>(<span>parser: argparse.ArgumentParser)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cybertensor.commands.delegates.DelegateUnstakeCommand.check_config"><code class="name flex">
<span>def <span class="ident">check_config</span></span>(<span>config: Config)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cybertensor.commands.delegates.DelegateUnstakeCommand.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>cli: <a title="cybertensor.cli" href="../cli.html">cybertensor.cli</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Undelegates stake from a chain delegate.</p></div>
</dd>
</dl>
</dd>
<dt id="cybertensor.commands.delegates.ListDelegatesCommand"><code class="flex name class">
<span>class <span class="ident">ListDelegatesCommand</span></span>
</code></dt>
<dd>
<div class="desc"><p>Displays a formatted table of Cybertensor network delegates, providing a comprehensive
overview of delegate statistics and information. This table helps users make informed
decisions on which delegates to allocate their GBOOT stake.</p>
<p>Optional Arguments:
- wallet.name: The name of the wallet to use for the command.
- cwtensor.network: The name of the network to use for the command.</p>
<p>The table columns include:
- INDEX: The delegate's index in the sorted list.
- DELEGATE: The name of the delegate.
- ADDR: The delegate's unique address (truncated for display).
- NOMINATORS: The count of nominators backing the delegate.
- DELEGATE STAKE(τ): The amount of delegate's own stake (not the GBOOT delegated from any nominators).
- TOTAL STAKE(τ): The delegate's cumulative stake, including self-staked and nominators' stakes.
- CHANGE/(4h): The percentage change in the delegate's stake over the last four hours.
- SUBNETS: The subnets to which the delegate is registered.
- VPERMIT: Indicates the subnets for which the delegate has validator permits.
- NOMINATOR/(24h)/kτ: The earnings per 1000 τ staked by nominators in the last 24 hours.
- DELEGATE/(24h): The total earnings of the delegate in the last 24 hours.
- DESCRIPTION: A brief description of the delegate's purpose and operations.</p>
<p>Sorting is done based on the 'TOTAL STAKE' column in descending order. Changes in stake
are highlighted: increases in green and decreases in red. Entries with no previous data
are marked with 'NA'. Each delegate's name is a hyperlink to their respective URL, if available.</p>
<p>Example usage:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ctcli root list_delegates
&gt;&gt;&gt; ctcli root list_delegates --wallet.name my_wallet
&gt;&gt;&gt; ctcli root list_delegates --cwtensor.network space-pussy # can also be &lt;code&gt;test&lt;/code&gt; or &lt;code&gt;local&lt;/code&gt;
</code></pre>
<p>Note:
This function is part of the Cybertensor CLI tools and is intended for use within a console
application. It prints directly to the console and does not return any value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ListDelegatesCommand:
    &#34;&#34;&#34;
    Displays a formatted table of Cybertensor network delegates, providing a comprehensive
    overview of delegate statistics and information. This table helps users make informed
    decisions on which delegates to allocate their GBOOT stake.

    Optional Arguments:
    - wallet.name: The name of the wallet to use for the command.
    - cwtensor.network: The name of the network to use for the command.

    The table columns include:
    - INDEX: The delegate&#39;s index in the sorted list.
    - DELEGATE: The name of the delegate.
    - ADDR: The delegate&#39;s unique address (truncated for display).
    - NOMINATORS: The count of nominators backing the delegate.
    - DELEGATE STAKE(τ): The amount of delegate&#39;s own stake (not the GBOOT delegated from any nominators).
    - TOTAL STAKE(τ): The delegate&#39;s cumulative stake, including self-staked and nominators&#39; stakes.
    - CHANGE/(4h): The percentage change in the delegate&#39;s stake over the last four hours.
    - SUBNETS: The subnets to which the delegate is registered.
    - VPERMIT: Indicates the subnets for which the delegate has validator permits.
    - NOMINATOR/(24h)/kτ: The earnings per 1000 τ staked by nominators in the last 24 hours.
    - DELEGATE/(24h): The total earnings of the delegate in the last 24 hours.
    - DESCRIPTION: A brief description of the delegate&#39;s purpose and operations.

    Sorting is done based on the &#39;TOTAL STAKE&#39; column in descending order. Changes in stake
    are highlighted: increases in green and decreases in red. Entries with no previous data
    are marked with &#39;NA&#39;. Each delegate&#39;s name is a hyperlink to their respective URL, if available.

    Example usage:
    &gt;&gt;&gt; ctcli root list_delegates
    &gt;&gt;&gt; ctcli root list_delegates --wallet.name my_wallet
    &gt;&gt;&gt; ctcli root list_delegates --cwtensor.network space-pussy # can also be `test` or `local`

    Note:
    This function is part of the Cybertensor CLI tools and is intended for use within a console
    application. It prints directly to the console and does not return any value.
    &#34;&#34;&#34;

    @staticmethod
    def run(cli: &#34;cybertensor.cli&#34;):
        r&#34;&#34;&#34;
        List all delegates on the network.
        &#34;&#34;&#34;
        try:
            # TODO revisit
            # cli.config.cwtensor.network = &#34;archive&#34;
            # cli.config.cwtensor.chain_endpoint = &#34;wss://archive.chain.opentensor.ai:443&#34;
            cwtensor = cybertensor.cwtensor(config=cli.config, log_verbose=False)
            with console.status(&#34;:satellite: Loading delegates...&#34;):
                # TODO added list, check get_deletates
                delegates: List[cybertensor.DelegateInfo] = cwtensor.get_delegates()
                try:
                    prev_delegates = cwtensor.get_delegates(max(0, cwtensor.block - 1200))
                except RuntimeError:
                    prev_delegates = None

            if prev_delegates is None:
                console.print(
                    &#34;:warning: [yellow]Could not fetch delegates history[/yellow]&#34;
                )

            show_delegates(
                cli.config,
                delegates,
                prev_delegates=prev_delegates,
                width=cli.config.get(&#34;width&#34;, None),
            )
        finally:
            if &#34;cwtensor&#34; in locals():
                cwtensor.close()
                cybertensor.logging.debug(&#34;closing cwtensor connection&#34;)

    @staticmethod
    def add_args(parser: argparse.ArgumentParser):
        list_delegates_parser = parser.add_parser(
            &#34;list_delegates&#34;, help=&#34;&#34;&#34;List all delegates on the network&#34;&#34;&#34;
        )
        cybertensor.cwtensor.add_args(list_delegates_parser)

    @staticmethod
    def check_config(config: &#34;Config&#34;):
        pass</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="cybertensor.commands.delegates.ListDelegatesCommand.add_args"><code class="name flex">
<span>def <span class="ident">add_args</span></span>(<span>parser: argparse.ArgumentParser)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cybertensor.commands.delegates.ListDelegatesCommand.check_config"><code class="name flex">
<span>def <span class="ident">check_config</span></span>(<span>config: Config)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cybertensor.commands.delegates.ListDelegatesCommand.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>cli: <a title="cybertensor.cli" href="../cli.html">cybertensor.cli</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>List all delegates on the network.</p></div>
</dd>
</dl>
</dd>
<dt id="cybertensor.commands.delegates.MyDelegatesCommand"><code class="flex name class">
<span>class <span class="ident">MyDelegatesCommand</span></span>
</code></dt>
<dd>
<div class="desc"><p>Executes the 'my_delegates' command within the Cybertensor CLI, which retrieves and
displays a table of delegated stakes from a user's wallet(s) to various delegates
on the Cybertensor network. The command provides detailed insights into the user's
staking activities and the performance of their chosen delegates.</p>
<p>Optional Arguments:
- wallet.name: The name of the wallet to use for the command.
- all: If specified, the command aggregates information across all wallets.</p>
<p>The table output includes the following columns:
- Wallet: The name of the user's wallet.
- OWNER: The name of the delegate's owner.
- ADDR: The truncated address of the delegate.
- Delegation: The amount of GBOOT staked by the user to the delegate.
- τ/24h: The earnings from the delegate to the user over the past 24 hours.
- NOMS: The number of nominators for the delegate.
- OWNER STAKE(τ): The stake amount owned by the delegate.
- TOTAL STAKE(τ): The total stake amount held by the delegate.
- SUBNETS: The list of subnets the delegate is a part of.
- VPERMIT: Validator permits held by the delegate for various subnets.
- 24h/kτ: Earnings per 1000 GBOOT staked over the last 24 hours.
- Desc: A description of the delegate.</p>
<p>The command also sums and prints the total amount of GBOOT delegated across all wallets.</p>
<p>Usage:
The command can be run as part of the Cybertensor CLI suite of tools and requires
no parameters if a single wallet is used. If multiple wallets are present, the
&ndash;all flag can be specified to aggregate information across all wallets.</p>
<p>Example usage:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ctcli root my_delegates
&gt;&gt;&gt; ctcli root my_delegates --all
&gt;&gt;&gt; ctcli root my_delegates --wallet.name my_wallet
</code></pre>
<p>Note:
This function is typically called by the CLI parser and is not intended to be used
directly in user code.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MyDelegatesCommand:
    &#34;&#34;&#34;
    Executes the &#39;my_delegates&#39; command within the Cybertensor CLI, which retrieves and
    displays a table of delegated stakes from a user&#39;s wallet(s) to various delegates
    on the Cybertensor network. The command provides detailed insights into the user&#39;s
    staking activities and the performance of their chosen delegates.

    Optional Arguments:
    - wallet.name: The name of the wallet to use for the command.
    - all: If specified, the command aggregates information across all wallets.

    The table output includes the following columns:
    - Wallet: The name of the user&#39;s wallet.
    - OWNER: The name of the delegate&#39;s owner.
    - ADDR: The truncated address of the delegate.
    - Delegation: The amount of GBOOT staked by the user to the delegate.
    - τ/24h: The earnings from the delegate to the user over the past 24 hours.
    - NOMS: The number of nominators for the delegate.
    - OWNER STAKE(τ): The stake amount owned by the delegate.
    - TOTAL STAKE(τ): The total stake amount held by the delegate.
    - SUBNETS: The list of subnets the delegate is a part of.
    - VPERMIT: Validator permits held by the delegate for various subnets.
    - 24h/kτ: Earnings per 1000 GBOOT staked over the last 24 hours.
    - Desc: A description of the delegate.

    The command also sums and prints the total amount of GBOOT delegated across all wallets.

    Usage:
    The command can be run as part of the Cybertensor CLI suite of tools and requires
    no parameters if a single wallet is used. If multiple wallets are present, the
    --all flag can be specified to aggregate information across all wallets.

    Example usage:
    &gt;&gt;&gt; ctcli root my_delegates
    &gt;&gt;&gt; ctcli root my_delegates --all
    &gt;&gt;&gt; ctcli root my_delegates --wallet.name my_wallet

    Note:
    This function is typically called by the CLI parser and is not intended to be used
    directly in user code.
    &#34;&#34;&#34;

    @staticmethod
    def run(cli: &#34;cybertensor.cli&#34;):
        &#34;&#34;&#34;Delegates stake to a chain delegate.&#34;&#34;&#34;
        try:
            config = cli.config.copy()
            cwtensor = cybertensor.cwtensor(config=config, log_verbose=False)
            MyDelegatesCommand._run(cli, cwtensor)
        finally:
            if &#34;cwtensor&#34; in locals():
                cwtensor.close()
                cybertensor.logging.debug(&#34;closing cwtensor connection&#34;)

    def _run(cli: &#34;cybertensor.cli&#34;, cwtensor: &#34;cybertensor.cwtensor&#34;):
        &#34;&#34;&#34;Delegates stake to a chain delegate.&#34;&#34;&#34;
        config = cli.config.copy()
        if config.get(&#34;all&#34;, d=None) is True:
            wallets = _get_coldkey_wallets_for_path(config.wallet.path)
        else:
            wallets = [Wallet(config=config)]

        table = Table(show_footer=True, pad_edge=False, box=None, expand=True)
        table.add_column(
            &#34;[overline white]Wallet&#34;, footer_style=&#34;overline white&#34;, style=&#34;bold white&#34;
        )
        table.add_column(
            &#34;[overline white]OWNER&#34;,
            style=&#34;rgb(50,163,219)&#34;,
            no_wrap=True,
            justify=&#34;left&#34;,
        )
        table.add_column(
            &#34;[overline white]ADDR&#34;, footer_style=&#34;overline white&#34;, style=&#34;bold yellow&#34;
        )
        table.add_column(
            &#34;[overline green]Delegation&#34;,
            footer_style=&#34;overline green&#34;,
            style=&#34;bold green&#34;,
        )
        table.add_column(
            f&#34;[overline green]{cwtensor.giga_token_symbol}/24h&#34;,
            footer_style=&#34;overline green&#34;,
            style=&#34;bold green&#34;,
        )
        table.add_column(
            &#34;[overline white]NOMS&#34;, justify=&#34;center&#34;, style=&#34;green&#34;, no_wrap=True
        )
        table.add_column(
            f&#34;[overline white]OWNER STAKE({cwtensor.giga_token_symbol})&#34;, justify=&#34;right&#34;, no_wrap=True
        )
        table.add_column(
            f&#34;[overline white]TOTAL STAKE({cwtensor.giga_token_symbol})&#34;,
            justify=&#34;right&#34;,
            style=&#34;green&#34;,
            no_wrap=True,
        )
        table.add_column(
            &#34;[overline white]SUBNETS&#34;, justify=&#34;right&#34;, style=&#34;white&#34;, no_wrap=True
        )
        table.add_column(&#34;[overline white]VPERMIT&#34;, justify=&#34;right&#34;, no_wrap=True)
        table.add_column(f&#34;[overline white]24h/k{cwtensor.giga_token_symbol}&#34;, style=&#34;green&#34;, justify=&#34;center&#34;)
        table.add_column(&#34;[overline white]Desc&#34;, style=&#34;rgb(50,163,219)&#34;)
        total_delegated = 0

        for wallet in tqdm(wallets):
            if not wallet.coldkeypub_file.exists_on_device():
                continue
            delegates = cwtensor.get_delegated(
                delegatee=wallet.coldkeypub.address
            )

            my_delegates = {}  # hotkey, amount
            for delegate in delegates:
                for coldkey_addr, staked in delegate[0].nominators:
                    if (
                        coldkey_addr == wallet.coldkeypub.address
                        and staked.gboot &gt; 0
                    ):
                        my_delegates[delegate[0].hotkey] = staked

            delegates.sort(key=lambda _delegate: _delegate[0].total_stake, reverse=True)
            total_delegated += sum(my_delegates.values())

            # TODO revisit
            # registered_delegate_info: Optional[
            #     DelegatesDetails
            # ] = get_delegates_details(url=cybertensor.__delegates_details_url__)

            registered_delegate_info: Optional[
                DelegatesDetails
            ] = cwtensor.get_delegates()

            if registered_delegate_info is None:
                console.print(
                    &#34;:warning:[yellow]Could not get delegate info from chain.[/yellow]&#34;
                )
                registered_delegate_info = {}

            for i, delegate in enumerate(delegates):
                owner_stake = next(
                    map(
                        lambda x: x[1],  # get stake
                        filter(
                            lambda x: x[0] == delegate[0].owner,
                            delegate[0].nominators,
                        ),  # filter for owner
                    ),
                    Balance.from_boot(0),  # default to 0 if no owner stake.
                )
                if delegate[0].hotkey in registered_delegate_info:
                    delegate_name = registered_delegate_info[
                        delegate[0].hotkey
                    ].name
                    delegate_url = registered_delegate_info[delegate[0].hotkey].url
                    delegate_description = registered_delegate_info[
                        delegate[0].hotkey
                    ].description
                else:
                    delegate_name = &#34;&#34;
                    delegate_url = &#34;&#34;
                    delegate_description = &#34;&#34;

                if delegate[0].hotkey in my_delegates:
                    table.add_row(
                        wallet.name,
                        Text(delegate_name, style=f&#34;link {delegate_url}&#34;),
                        f&#34;{delegate[0].hotkey[:16]}...{delegate[0].hotkey[-8:]}&#34;,
                        f&#34;{my_delegates[delegate[0].hotkey]!s:16.16}&#34;,
                        f&#34;{delegate[0].total_daily_return.gboot * (my_delegates[delegate[0].hotkey] / delegate[0].total_stake.gboot)!s:6.6}&#34;,
                        str(len(delegate[0].nominators)),
                        f&#34;{owner_stake!s:13.13}&#34;,
                        f&#34;{delegate[0].total_stake!s:13.13}&#34;,
                        str(delegate[0].registrations),
                        str(
                            [
                                &#34;*&#34; if subnet in delegate[0].validator_permits else &#34;&#34;
                                for subnet in delegate[0].registrations
                            ]
                        ),
                        # f&#39;{delegate.take * 100:.1f}%&#39;,s
                        f&#34;{delegate[0].total_daily_return.gboot * (1000 / (0.001 + delegate[0].total_stake.gboot))!s:6.6}&#34;,
                        str(delegate_description),
                        # f&#39;{delegate_profile.description:140.140}&#39;,
                    )

        console.print(table)
        console.print(f&#34;Total delegated {cwtensor.giga_token_symbol}: {total_delegated}&#34;)

    @staticmethod
    def add_args(parser: argparse.ArgumentParser):
        delegate_stake_parser = parser.add_parser(
            &#34;my_delegates&#34;,
            help=&#34;&#34;&#34;Show all delegates where I am delegating a positive amount of stake&#34;&#34;&#34;,
        )
        delegate_stake_parser.add_argument(
            &#34;--all&#34;,
            action=&#34;store_true&#34;,
            help=&#34;&#34;&#34;Check all coldkey wallets.&#34;&#34;&#34;,
            default=False,
        )
        Wallet.add_args(delegate_stake_parser)
        cybertensor.cwtensor.add_args(delegate_stake_parser)

    @staticmethod
    def check_config(config: &#34;Config&#34;):
        if (
            not config.get(&#34;all&#34;, d=None)
            and not config.is_set(&#34;wallet.name&#34;)
            and not config.no_prompt
        ):
            wallet_name = Prompt.ask(&#34;Enter wallet name&#34;, default=defaults.wallet.name)
            config.wallet.name = str(wallet_name)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="cybertensor.commands.delegates.MyDelegatesCommand.add_args"><code class="name flex">
<span>def <span class="ident">add_args</span></span>(<span>parser: argparse.ArgumentParser)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cybertensor.commands.delegates.MyDelegatesCommand.check_config"><code class="name flex">
<span>def <span class="ident">check_config</span></span>(<span>config: Config)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cybertensor.commands.delegates.MyDelegatesCommand.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>cli: <a title="cybertensor.cli" href="../cli.html">cybertensor.cli</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Delegates stake to a chain delegate.</p></div>
</dd>
</dl>
</dd>
<dt id="cybertensor.commands.delegates.NominateCommand"><code class="flex name class">
<span>class <span class="ident">NominateCommand</span></span>
</code></dt>
<dd>
<div class="desc"><p>Executes the 'nominate' command, which facilitates a wallet to become a delegate
on the Cybertensor network. This command handles the nomination process, including
wallet unlocking and verification of the hotkey's current delegate status.</p>
<p>The command performs several checks:
- Verifies that the hotkey is not already a delegate to prevent redundant nominations.
- Tries to nominate the wallet and reports success or failure.</p>
<p>Upon success, the wallet's hotkey is registered as a delegate on the network.</p>
<p>Optional Arguments:
- wallet.name: The name of the wallet to use for the command.
- wallet.hotkey: The name of the hotkey to use for the command.</p>
<p>Usage:
To run the command, the user must have a configured wallet with both hotkey and
coldkey. If the wallet is not already nominated, this command will initiate the
process.</p>
<p>Example usage:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ctcli root nominate
&gt;&gt;&gt; ctcli root nominate --wallet.name my_wallet --wallet.hotkey my_hotkey
</code></pre>
<p>Note:
This function is intended to be used as a CLI command. It prints the outcome directly
to the console and does not return any value. It should not be called programmatically
in user code due to its interactive nature and side effects on the network state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NominateCommand:
    &#34;&#34;&#34;
    Executes the &#39;nominate&#39; command, which facilitates a wallet to become a delegate
    on the Cybertensor network. This command handles the nomination process, including
    wallet unlocking and verification of the hotkey&#39;s current delegate status.

    The command performs several checks:
    - Verifies that the hotkey is not already a delegate to prevent redundant nominations.
    - Tries to nominate the wallet and reports success or failure.

    Upon success, the wallet&#39;s hotkey is registered as a delegate on the network.

    Optional Arguments:
    - wallet.name: The name of the wallet to use for the command.
    - wallet.hotkey: The name of the hotkey to use for the command.

    Usage:
    To run the command, the user must have a configured wallet with both hotkey and
    coldkey. If the wallet is not already nominated, this command will initiate the
    process.

    Example usage:
    &gt;&gt;&gt; ctcli root nominate
    &gt;&gt;&gt; ctcli root nominate --wallet.name my_wallet --wallet.hotkey my_hotkey

    Note:
    This function is intended to be used as a CLI command. It prints the outcome directly
    to the console and does not return any value. It should not be called programmatically
    in user code due to its interactive nature and side effects on the network state.
    &#34;&#34;&#34;

    @staticmethod
    def run(cli: &#34;cybertensor.cli&#34;):
        r&#34;&#34;&#34;Nominate wallet.&#34;&#34;&#34;
        try:
            wallet = Wallet(config=cli.config)
            cwtensor = cybertensor.cwtensor(config=cli.config)

            # Unlock the wallet.
            wallet.hotkey
            wallet.coldkey

            # Check if the hotkey is already a delegate.
            if cwtensor.is_hotkey_delegate(wallet.hotkey.address):
                console.print(
                    &#34;Aborting: Hotkey {} is already a delegate.&#34;.format(
                        wallet.hotkey.address
                    )
                )
                return

            result: bool = cwtensor.nominate(wallet)
            if not result:
                console.print(
                    &#34;Could not became a delegate on [white]{}[/white]&#34;.format(
                        cwtensor.network
                    )
                )
            else:
                # Check if we are a delegate.
                is_delegate: bool = cwtensor.is_hotkey_delegate(wallet.hotkey.address)
                if not is_delegate:
                    console.print(
                        &#34;Could not became a delegate on [white]{}[/white]&#34;.format(
                            cwtensor.network
                        )
                    )
                    return
                console.print(
                    &#34;Successfully became a delegate on [white]{}[/white]&#34;.format(
                        cwtensor.network
                    )
                )
            # # Prompt use to set identity on chain.
            # if not cli.config.no_prompt:
            #     do_set_identity = Prompt.ask(
            #         f&#34;Subnetwork registered successfully. Would you like to set your identity? [y/n]&#34;,
            #         choices=[&#34;y&#34;, &#34;n&#34;],
            #     )
            #
            #     if do_set_identity.lower() == &#34;y&#34;:
            #         cwtensor.close()
            #         config = cli.config.copy()
            #         SetIdentityCommand.check_config(config)
            #         cli.config = config
            #         SetIdentityCommand.run(cli)
        finally:
            if &#34;cwtensor&#34; in locals():
                cwtensor.close()
                cybertensor.logging.debug(&#34;closing cwtensor connection&#34;)


    @staticmethod
    def add_args(parser: argparse.ArgumentParser):
        nominate_parser = parser.add_parser(
            &#34;nominate&#34;, help=&#34;&#34;&#34;Become a delegate on the network&#34;&#34;&#34;
        )
        Wallet.add_args(nominate_parser)
        cybertensor.cwtensor.add_args(nominate_parser)

    @staticmethod
    def check_config(config: &#34;Config&#34;):
        if not config.is_set(&#34;wallet.name&#34;) and not config.no_prompt:
            wallet_name = Prompt.ask(&#34;Enter wallet name&#34;, default=defaults.wallet.name)
            config.wallet.name = str(wallet_name)

        if not config.is_set(&#34;wallet.hotkey&#34;) and not config.no_prompt:
            hotkey = Prompt.ask(&#34;Enter hotkey name&#34;, default=defaults.wallet.hotkey)
            config.wallet.hotkey = str(hotkey)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="cybertensor.commands.delegates.NominateCommand.add_args"><code class="name flex">
<span>def <span class="ident">add_args</span></span>(<span>parser: argparse.ArgumentParser)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cybertensor.commands.delegates.NominateCommand.check_config"><code class="name flex">
<span>def <span class="ident">check_config</span></span>(<span>config: Config)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cybertensor.commands.delegates.NominateCommand.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>cli: <a title="cybertensor.cli" href="../cli.html">cybertensor.cli</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Nominate wallet.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cybertensor.commands" href="index.html">cybertensor.commands</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="cybertensor.commands.delegates.show_delegates" href="#cybertensor.commands.delegates.show_delegates">show_delegates</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cybertensor.commands.delegates.DelegateStakeCommand" href="#cybertensor.commands.delegates.DelegateStakeCommand">DelegateStakeCommand</a></code></h4>
<ul class="">
<li><code><a title="cybertensor.commands.delegates.DelegateStakeCommand.add_args" href="#cybertensor.commands.delegates.DelegateStakeCommand.add_args">add_args</a></code></li>
<li><code><a title="cybertensor.commands.delegates.DelegateStakeCommand.check_config" href="#cybertensor.commands.delegates.DelegateStakeCommand.check_config">check_config</a></code></li>
<li><code><a title="cybertensor.commands.delegates.DelegateStakeCommand.run" href="#cybertensor.commands.delegates.DelegateStakeCommand.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cybertensor.commands.delegates.DelegateUnstakeCommand" href="#cybertensor.commands.delegates.DelegateUnstakeCommand">DelegateUnstakeCommand</a></code></h4>
<ul class="">
<li><code><a title="cybertensor.commands.delegates.DelegateUnstakeCommand.add_args" href="#cybertensor.commands.delegates.DelegateUnstakeCommand.add_args">add_args</a></code></li>
<li><code><a title="cybertensor.commands.delegates.DelegateUnstakeCommand.check_config" href="#cybertensor.commands.delegates.DelegateUnstakeCommand.check_config">check_config</a></code></li>
<li><code><a title="cybertensor.commands.delegates.DelegateUnstakeCommand.run" href="#cybertensor.commands.delegates.DelegateUnstakeCommand.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cybertensor.commands.delegates.ListDelegatesCommand" href="#cybertensor.commands.delegates.ListDelegatesCommand">ListDelegatesCommand</a></code></h4>
<ul class="">
<li><code><a title="cybertensor.commands.delegates.ListDelegatesCommand.add_args" href="#cybertensor.commands.delegates.ListDelegatesCommand.add_args">add_args</a></code></li>
<li><code><a title="cybertensor.commands.delegates.ListDelegatesCommand.check_config" href="#cybertensor.commands.delegates.ListDelegatesCommand.check_config">check_config</a></code></li>
<li><code><a title="cybertensor.commands.delegates.ListDelegatesCommand.run" href="#cybertensor.commands.delegates.ListDelegatesCommand.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cybertensor.commands.delegates.MyDelegatesCommand" href="#cybertensor.commands.delegates.MyDelegatesCommand">MyDelegatesCommand</a></code></h4>
<ul class="">
<li><code><a title="cybertensor.commands.delegates.MyDelegatesCommand.add_args" href="#cybertensor.commands.delegates.MyDelegatesCommand.add_args">add_args</a></code></li>
<li><code><a title="cybertensor.commands.delegates.MyDelegatesCommand.check_config" href="#cybertensor.commands.delegates.MyDelegatesCommand.check_config">check_config</a></code></li>
<li><code><a title="cybertensor.commands.delegates.MyDelegatesCommand.run" href="#cybertensor.commands.delegates.MyDelegatesCommand.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cybertensor.commands.delegates.NominateCommand" href="#cybertensor.commands.delegates.NominateCommand">NominateCommand</a></code></h4>
<ul class="">
<li><code><a title="cybertensor.commands.delegates.NominateCommand.add_args" href="#cybertensor.commands.delegates.NominateCommand.add_args">add_args</a></code></li>
<li><code><a title="cybertensor.commands.delegates.NominateCommand.check_config" href="#cybertensor.commands.delegates.NominateCommand.check_config">check_config</a></code></li>
<li><code><a title="cybertensor.commands.delegates.NominateCommand.run" href="#cybertensor.commands.delegates.NominateCommand.run">run</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
